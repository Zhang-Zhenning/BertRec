
EE 376A: Information Theory

Lecture Notes

Prof. Tsachy Weissman

TA: Idoia Ochoa, Kedar Tatwawadi

January 6, 2016


Contents

1

Introduction

1

1.1

Lossless Compression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1

1.2

Channel Coding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3

1.3

Lossy Compression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5

2

Entropy, Relative Entropy, and Mutual Information

6

2.1

Entropy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

6

2.2

Conditional and Joint Entropy

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

9

2.3

Mutual Information

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

11

3

Asymptotic Equipartition Properties

12

3.1

Asymptotic Equipartition Property (AEP) . . . . . . . . . . . . . . . . . . . . . . . .

12

3.2

Fixed Length (Near) Lossless Compression . . . . . . . . . . . . . . . . . . . . . . . .

15

4

Lossless Compression

18

4.1

Uniquely decodable codes and preﬁx codes . . . . . . . . . . . . . . . . . . . . . . . .

18

4.2

Preﬁx code for dyadic distributions . . . . . . . . . . . . . . . . . . . . . . . . . . . .

20

4.3

Shannon codes

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

21

4.4

Average codelength bound for uniquely decodable codes . . . . . . . . . . . . . . . .

22

4.5

Huﬀman Coding

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

24

4.6

Optimality of Huﬀman codes

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

25

5

Communication and Channel Capacity

28

5.1

The Communication Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

28

5.2

Channel Capacity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

29

5.2.1

Channel Capacity of various discrete channels . . . . . . . . . . . . . . . . . .

30

5.2.2

Recap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

31

5.3

Information Measures for Continuous Random Variables . . . . . . . . . . . . . . . .

32

5.3.1

Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

33

5.3.2

Gaussian Distribution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

34

5.4

Channel Capacity of the AWGN Channel (Additive White Gaussian Noise) . . . . .

34

5.4.1

Channel Coding Theorem for this Setting . . . . . . . . . . . . . . . . . . . .

35

5.4.2

An Aside: Cost Constraint

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

35

5.4.3

The Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

35

5.4.4

Rough Geometric Interpretation (Picture) . . . . . . . . . . . . . . . . . . . .

36

i


5.5

Joint Asymptotic Equipartition Property (AEP)

. . . . . . . . . . . . . . . . . . . .

38

5.5.1

Set of Jointly Typical Sequences

. . . . . . . . . . . . . . . . . . . . . . . . .

38

5.6

Direct Theorem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

39

5.7

Fano’s Inequality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

40

5.8

Converse Theorem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

41

5.9

Some Notes on the Direct and Converse Theorems . . . . . . . . . . . . . . . . . . .

42

5.9.1

Communication with Feedback: Xi(J, Y i−1) . . . . . . . . . . . . . . . . . . .

42

5.9.2

Practical Schemes

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

42

5.9.3

Pe vs. Pmax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

42

6

Method of Types

45

6.1

Method of Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

45

6.1.1

Recap on Types

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

48

6.2

A Version of Sanov’s Theorem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

48

7

Conditional and Joint Typicality

52

7.1

Typical Set (again) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

52

7.2

δ–strongly typical set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

52

7.3

δ–jointly typical set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

54

7.4

δ–conditional typicality

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

56

7.5

Encoding – Decoding Schemes for Sending Messages . . . . . . . . . . . . . . . . . .

56

7.6

Joint Typicality Lemma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

58

8

Lossy Compression &amp; Rate Distortion Theory

59

8.1

Deﬁnitions and main result

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

59

8.2

Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

60

8.3

Proof of Direct Part R(D) ≤ R(I)(D) . . . . . . . . . . . . . . . . . . . . . . . . . . .

62

8.3.1

An Equivalent Statement

. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

62

8.3.2

Two Useful Lemmas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

63

8.3.3

Proof of the Equivalent Statement . . . . . . . . . . . . . . . . . . . . . . . .

63

8.4

Proof of the converse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

65

8.5

Geometric Interpretation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

66

9

Joint Source Channel Coding

68

9.1

Joint Source Channel Coding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

68

9.2

Source – Channel Separation Theorem . . . . . . . . . . . . . . . . . . . . . . . . . .

69

9.3

Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

70

EE376A COURSE NOTES

ii


Chapter 1

Introduction

Information theory is the science of operations on data such as compression, storage, and com-

munication. It is among the few disciplines fortunate to have a precise date of birth: 1948, with

the publication of Claude E. Shannon’s paper entitled A Mathematical Theory of Communication.

Shannon’s Information theory had a profound impact on our understanding of the concepts in

communication.

In this introductory chapter, we will look at a few representative examples which try to give

a ﬂavour of the problems which can be addressed using information theory. However note that,

communication theory, is just one of the numerous ﬁelds which had a dramatic shift in the under-

standing due to information theory.

1.1

Lossless Compression

Consider a source that emits a sequence of symbols U1, U2, . . . with Ui ∈ {a, b, c}. The Ui are i.i.d

(independently and identically distributed) according to the probability mass function

P(U = a) = 0.7

P(U = b) = P(U = c) = 0.15

Our task is to encode the source sequence into binary bits (1s and 0s). How should we do so?

The naive way is to use two bits to represent each symbol, since there are three possible

symbols. For example, we can use 00 to represent a, 01 to represent b and 10 to represent c. This

scheme has an expected codeword length of 2 bits per source symbol. Can we do better? One

natural improvement is to try to use fewer bits to represent symbols that appear more often. For

example, we can use the single bit 0 to represent a since a is the most common symbol, and 10 to

represent b and 11 to represent c since they are less common. Note that this code satisﬁes the preﬁx

condition, meaning no codeword is the preﬁx of another codeword, which allows us to decode a

message consisting of stream of bits without any ambiguity. Thus, if we see the encoded sequence,

001101001101011, we can quickly decode it as follows:

0

����

a

0

����

a

11

����

c

0

����

a

10

����

b

0

����

a

11

����

c

0

����

a

10

����

b

11

����

c

1


If we use this encoding scheme, then L, which denotes the expected number of bits we use per

source symbol, is

L = 1 × P(U = a) + 2 × (P(U = b) + P(U = c)) = 1 × 0.7 + 2 × (0.15 + 0.15) = 1.3.

This is a signiﬁcant improvement over our ﬁrst encoding scheme. But can we do even better? A

possible improvement is to encode two values at a time instead of encoding each value individually.

For example, the following table shows all the possibilities we can get if we look at 2 values, and

their respective probabilities (listed in order of most to least likely pairs). A possible preﬁx coding

scheme is also given.

source symbols

probability

encoding

aa

0.49

0

ab

0.105

100

ac

0.105

111

ba

0.105

101

ca

0.105

1100

bb

0.0225

110100

bc

0.0225

110101

cb

0.0225

110110

cc

0.0225

110111

Note that this scheme satisﬁes the two important properties: 1) the preﬁx condition and 2)

more common source symbol pairs have shorter codewords. If we use the above encoding scheme,

then the expected number of bits used per source symbol is

L = 0.5 × (0.49 × 1 + 0.105 × 4 + 0.105 × 3 × 3 + 0.0225 × 6 × 4) = 1.1975.

It can be proven that if we are to encode 2 values at a time, the above encoding scheme achieves

the lowest average number of bits per value (*wink* Huﬀman encoding *wink*).

Generalizing the above idea, we can consider a family of encoding schemes indexed by an integer

k. Given an integer k, we can encode k values at a time with a scheme that satisﬁes the preﬁx

condition and assigns shorter codewords to more common symbols. Under some optimal encoding

scheme, it seems reasonable that the expected number of bits per value will decrease as k increases.

We may ask, what is the best we can do? Is there a lower bound on L? Shannon proved that

given any such source, the best we can do is H(U), which is called the Entropy of the source . By

deﬁnition, the source entropy is

H(U) ≜

�

u∈U

p(u) log2

1

p(u)

(1.1)

Thus, Shannon proved the following statement1,

Theorem 1. ∀ families of encoding schemes, the average codeword length, L ≥ H(U).

1Note that the statements of the theorems here will be informal; they will be made rigorous in later lectures.

EE376A COURSE NOTES

2


For our example, the lower bound is thus

0.7 × log2

1

0.7 + 2 × 0.15 × log2

1

0.15 ≈ 1.181

We will also show an upper bound, namely,

Theorem 2. ∀ε &gt; 0, ∃ family of schemes, such that the average codeword length, L ≤ H(U) + ε.

1.2

Channel Coding

Suppose we have a source that emits a stream of bits U1, U2, . . . The Ui ∈ {0, 1} are i.i.d. Bernoulli

random variables with parameter 0.5, or fair coin ﬂips.

We want to transmit the bits Ui through a channel. Suppose the bits that are transmitted are

X1, X2, . . . The channel is noisy and ﬂips each bit with probability q &lt; 1/2. Therefore, if Y1, Y2, . . .

is the sequence of bits that we receive, we have

Yi = Xi ⊕ Wi, Wi ∼ Ber(q)

where ⊕ is the XOR operator.

We want to know how accurate we can be when transmitting the bits. The simplest approach

is to let Xi = Ui, and to decode the received bit by assuming Yi = Xi. Let pe be the probability of

error per source bit. Then in this case, pe = q &lt; 1/2.

Can we decrease pe? One approach may be to use repetition encoding, i.e., send each bit k

times for some k, and then decode the received bit as the value that appeared most among the k

received symbols. For example, if k = 3, then pe is simply the probability that the channel ﬂipped

2 or more of the bits, which is

pe = 3(1 − q)q2 + q3 &lt; q.

However, we need to send 3 times as many bits. To quantify this, we introduce the notion of bit

rate, denoted by R, which is the ratio of the number of bits sent to the units of channel space

used. For this scheme, our bit rate is 1

3, whereas our bit rate in the previous example was 1.

Generalizing the above example, we see that as we increase k, our error rate pe will tend to 0,

but our bit rate R (which is 1/k) tends to 0 as well. Is there some scheme that has a signiﬁcant

positive bit rate and yet allows us to get reliable communication (error rate tends to 0)? Again,

Shannon provides the answer.

Theorem 3. ∃C &gt; 0 and ∃ family of schemes with R &lt; C satisfying pe → 0.

In fact, the largest such C is known as the channel capacity of a channel, which represents

the largest bit rate ( the largest C ) that still allows for reliable communication. This was a very

signiﬁcant and a startling revelation for the world of communication, as it was thought that zero

error probability is not achievable with a non-zero bit rate.

As examples, we will consider the channel capacity of the binary symmetric channel and the

additive white gaussian noise channel.

EE376A COURSE NOTES

3


Binary Symmetric Channel

The channel capacity of a binary symmetric channel with bit-ﬂipping probability q is

1 − H(X), X ∼ Ber(q).

(1.2)

Moreover, if we let X ∼ Ber(q) and Y ∼ Ber(pe), we will see that a bit rate R such that

R &lt; 1 − H(X)

1 − H(Y ) ,

(1.3)

is achievable, whereas

R &gt; 1 − H(X)

1 − H(Y ) ,

(1.4)

is unachievable.

Additive White Gaussian Noise (AWGN) Channel

Suppose we have a source that emits a sequence of bits U1, U2, . . . , UN, where each Ui is i.i.d.

according to U ∼ Ber(1

2).

However, we can only transmit real numbers X1, X2, . . . , Xn. Also, the channel contains some

noise. Speciﬁcally, if Y1, Y2, . . . , Yn is the sequence of values we receive, we have

Yi = Xi + Ni, Ni ∼ N(0, σ2)

The rate of transmission is the ratio N

n (which is the ratio of the number of source bits to the

number of uses of the channel). We want to develop a scheme so that we can reliably reconstruct

Ui from the given Yi. One way, if we have no usage power constraint, is to make Xi a large positive

value if Ui = 1 and Xi a large negative value if Ui = 0. In this manner, the noise from Ni will be

trivial relative to the signal magnitude, and will not impact reconstruction too much. However,

suppose there is an additional constraint on the average power of the transmitted signal, such that

we require

1

n

n

�

i=1

X2

i ≤ p,

for a given value p. In fact, we will see that

Theorem 4. If the rate of transmission is &lt; 1

2 log2

�

1 + p

σ2

�

, then ∃ family of schemes that com-

municate reliably. And if the rate of transmission is &gt; 1

2 log2

�

1 + p

σ2

�

, then there is no family of

schemes which communicates reliably.

The ratio p

σ2 is referred to as the signal-to-noise ratio (SNR).

EE376A COURSE NOTES

4


1.3

Lossy Compression

Suppose we have a source that emits a sequence of values U1, U2, . . ., where the Ui is i.i.d random

variables. according to U ∼ N(0, σ2). Suppose we want to encode the source using one bit per

value. Since we are representing continuous variables with discrete bits, we are employing lossy

compression. Can we come up with a scheme that reconstructs the original signal as accurately as

possible, based on the bits sent?

Let B1, B2, . . . be the bits sent. One natural scheme is to set

Bi =

�

1

if Ui ≥ 0

0

if Ui &lt; 0.

After receiving the bits, let V1, V2, . . . be the reconstructed values. The distortion of the scheme

is deﬁned as

D ≜ E[(Ui − Vi)2]

(1.5)

The optimal estimation rule for minimum mean squared error is the conditional expectation.

Therefore, to minimize distortion, we should reconstruct via Vi = E[Ui | Bi]. This results in

D = E[(Ui − Vi)2]

= V ar(Ui | Bi)

= 0.5 × V ar(Ui | Bi = 1) + 0.5 × V ar(Ui | Bi = 0) (because U is symmetric)

= V ar(Ui | Bi = 1)

= E[U2

i | Bi = 1] − (E[Ui | Bi = 1])2

= σ2

�

1 − 2

π

�

≈ 0.363σ2.

We will see in fact that 0.363σ2 can be improved considerably, as such:

Theorem 5. Consider a Gaussian memoryless source with mean µ and variance σ2. ∀ε &gt; 0, ∃

family of schemes such that D ≤ σ2/4 + ε. Moreover, ∀ families of schemes, D ≥ σ2/4.

As we saw, the few examples signify the usefulness of information theory to the ﬁeld of communi-

cations. In the next few chapters, we will try to build the mathematical foundations for the theory

of information theory, which will make it much more convenient for us to use them later on.

EE376A COURSE NOTES

5


Chapter 2

Entropy, Relative Entropy, and

Mutual Information

In this chapter ,we will introduce certain key measures of information, that play crucial roles in

theoretical and operational characterizations throughout the course. These include the entropy, the

mutual information, and the relative entropy. We will also exhibit some key properties exhibited

by these information measures.

Notation

A quick summary of the notation

1. Random Variables (objects): used more “loosely", i.e. X, Y, U, V

2. Alphabets: X, Y, U, V

3. Speciﬁc Values: x, y, u, v

For discrete random variable (object), U has p.m.f: PU(u) ≜ P(U = u). Often, we’ll just write

p(u). Similarly: p(x, y) for PX,Y (x, y) and p(y|x) for PY |X(y|x), etc.

2.1

Entropy

Before we understand entropy, let us take a look at the "surprise function", which will give us more

intuition into the deﬁnition of entropy.

Deﬁnition 6. "Surprise Function":

s(u) ≜ log

1

p(u)

The surprise function represents the amount of surprise or the amount of information a partic-

ular symbol u of a distribution holds. Intuitively the deﬁnition can be understood as follows: we

would be surprised if a rare symbol ( p(u) is small ) is observed. Thus, lower the p(u), higher the

surprise, which is what achieved by the above deﬁnition.

6


Deﬁnition 7. Entropy: Let U a discrete R.V. taking values in U. The entropy of U is deﬁned

by:

H(U) ≜

�

u∈U

p(u) log

1

p(u) ≜ E[s(u)]

(2.1)

The Entropy represents the expected value of surprise a distribution holds. Intuitively, the

more the expected surprise or the entropy of the distribution, the harder it is to represent.

Note: The entropy H(U) is not a random variable. In fact it is not a function of the object

U, but rather a functional (or property) of the underlying distribution P (u)

U , u ∈ U. An analogy is

E[U], which is also a number (the mean) corresponding to the distribution.

Properties of Entropy

Although almost everyone would have encountered the Jensen’s Inequality in their calculus class,

we take a brief look at it in a form most useful for information theory. Jensen’s Inequality: Let

Q denote a convex function, and X denote any random variable. Jensen’s inequality states that

E[Q(X)] ≥ Q(E[X]).

(2.2)

Further, if Q is strictly convex, equality holds iﬀ X is deterministic.

Example: Q(x) = ex is a

convex function. Therefore, for a random variable X, we have by Jensen’s inquality:

E[eX] ≥ eE[X]

Conversely, if Q is a concave function, then

E[Q(X) ≤ Q(E[X]).

(2.3)

Example: Q(x) = log x is a concave function. Therefore, for a random variable X ≥ 0,

E[log X] ≤ log E[X]

(2.4)

W.L.O.G suppose U = {1,2,...,m}

1. H(U) ≤ log m, with equality iﬀ P(u) = 1

m∀u (i.e. uniform).

Proof:

H(U) = E[log

1

p(u)]

(2.5)

≤ log E[ 1

p(u)] (Jensen’s inequality, since log is concave)

(2.6)

= log

�

u

p(u) ·

1

p(u)

(2.7)

= log m.

(2.8)

Equality in Jensen, iﬀ

1

p(u) is deterministic, iﬀ p(u) = 1

m

EE376A COURSE NOTES

7


2. H(U) ≥ 0, with equality iﬀ U is deterministic.

Proof:

H(U) = E[log

1

p(u)] ≥ 0 since log

1

p(u) ≥ 0

(2.9)

The equality occurs iﬀ log

1

P(U) = 0 with probability 1, iﬀ P(U) = 1 w.p. 1 iﬀ U is determin-

istic.

3. For a PMF q, deﬁned on the same alphabet as p, deﬁne

Hq(U) ≜

�

u∈U

p(u) log

1

q(u).

(2.10)

Note that this is the expected surprise function, but instead of the surprise associated with

p, it is the surprise associated U, which is distributed according to PMF p, but incorrectly

assumed to be having the PMF of q. The following result stipulates, that we will (on average)

be more surprised if we had the wrong distribution in mind. This makes intuitive sense!

Mathematically,

H(U) ≤ Hq(U),

(2.11)

with equality iﬀ q = p.

Proof:

H(U) − Hq(U) = E

�

log

1

p(u)

�

− E

�

log

1

q(u)

�

(2.12)

H(U) − Hq(U) = E

�

log q(u)

p(u)

�

(2.13)

By Jensen’s, we know that E

�

log q(u)

p(u)

�

≤ log E

� q(u)

p(u)

�

, so

H(U) − Hq(U) ≤ log E

�q(u)

p(u)

�

(2.14)

= log

�

u∈U

p(u)q(u)

p(u)

(2.15)

= log

�

u∈U

q(u)

(2.16)

= log 1

(2.17)

= 0

(2.18)

Therefore, we see that

H(U) − Hq(U) ≤ 0.

Equality only holds when Jensen’s yields equality. That only happens when q(u)

p(u) is determin-

istic, which only occurs when q = p, i.e. the distributions are identical.

EE376A COURSE NOTES

8


Deﬁnition 8. Relative Entropy. An important measure of distance between probability

measures is relative entropy, or the Kullback–Leibler divergence:

D(p||q) ≜

�

u∈U

p(u) log p(u)

q(u) = E

�

log p(u)

q(u)

�

(2.19)

Note that property 3 is equivalent to saying that the relative entropy is always greater than

or equal to 0, with equality iﬀ q = p (convince yourself).

4. If X1, X2, . . . , Xn are independent random variables, then

H(X1, X2, . . . , Xn) =

n

�

i=1

H(Xi)

(2.20)

Proof:

H(X1, X2, . . . , Xn) = E

�

log

1

p(x1, x2, . . . , xn)

�

(2.21)

= E [− log p(x1, x2, . . . , xn)]

(2.22)

= E [− log p(x1)p(x2) . . . p(xn)]

(2.23)

= E

�

−

n

�

i=1

log p(xi)

�

(2.24)

=

n

�

i=1

E [− log p(xi)]

(2.25)

=

n

�

i=1

H(Xi).

(2.26)

Therefore, the entropy of independent random variables is the sum of the individual entropies.

This is also intuitive, since the uncertainty (or surprise) associated with each random variable

is independent.

2.2

Conditional and Joint Entropy

We deﬁned the entropy of a random variable U. We also saw that when U is a joint random variable

of independent variables, then H(U) is the sum of the individual entropies. Can we say anything

more in general for a joint random variable?

Deﬁnition 9. Conditional Entropy of X given Y

H(X|Y ) ≜ E

� log

1

P(X|Y )

�

(2.27)

=

�

x,y

Pr [x, y]

1

log P(x|y)

(2.28)

=

�

y

P(y)

� �

x

P(x|y)

1

log P(x|y)

�

(2.29)

=

�

y

P(y)H(X|y).

(2.30)

EE376A COURSE NOTES

9


Note: The conditional entropy is a functional of the joint distribution of (X, Y ). Note that this

is also a number, and denotes the “average” surprise in X when we observe Y. Here, by deﬁnition,

we also average over the realizations of Y. Note that the conditional entropy is NOT a function of

the random variable Y . In this sense, it is very diﬀerent from a familar object in probability, the

conditional expectation E[X|Y ] which is a random variable (and a function of Y ).

Deﬁnition 10. Joint Entropy of X and Y

H(X, Y ) ≜ E

� log

1

P(X, Y )

�

(2.31)

= E

� log

1

P(X)P(Y |X)]

(2.32)

Properties of conditional and Joint entropy

1. H(X|Y ) ≤ H(X), equal iﬀ X ⊥ Y

Proof:

H(X) − H(X|Y ) = E

� log

1

P(X)

� − E

� log

1

P(X|Y )

�

(2.33)

= E

� log P(X|Y )

P(X)

P(Y )

P(Y )

� = E

� log

P(X, Y )

P(X)P(Y )]

(2.34)

=

�

x,y

P(x, y) log

P(x, y)

P(x)P(y)

(2.35)

= D(Px,y||Px × Py)

(2.36)

≥ 0

equal iﬀ X ⊥ Y.

(2.37)

The last step follows from the non-negativity of relative entropy. Equality holds iﬀ Px,y ≡

Px × Py, i.e. X and Y are independent.

2. Chain rule for entropy:

H(X, Y ) = H(X) + H(Y |X)

(2.38)

= H(Y ) + H(X|Y )

(2.39)

3. Sub-additivity of entropy

H(X, Y ) ≤ H(X) + H(Y ),

(2.40)

with equality iﬀ X ⊥ Y (follows from the property that conditioning does not increase

entropy)

EE376A COURSE NOTES

10


2.3

Mutual Information

Deﬁnition 11. Mutual information between X and Y

We now deﬁne the mutual information between random variables X and Y distributed according

to the joint PMF P(x, y):

I(X, Y ) ≜ H(X) + H(Y ) − H(X, Y )

(2.41)

= H(Y ) − H(Y |X)

(2.42)

= H(X) − H(X|Y )

(2.43)

= D(Px,y||Px × Py)

(2.44)

The mutual information is a canonical measure of the information conveyed by one random variable

about another. The deﬁnition tells us that it is the reduction in average surprise, upon observing a

correlated random variable. The mutual information is again a functional of the joint distribution

of the pair (X, Y ). It can also be viewed as the relative entropy between the joint distribution, and

the product of the marginals

1. I(X; Y ) ≥ 0, coming from the fact that H(Y ) ≥ H(Y |X).

2. I(X; Y ) ≤ min{H(X), H(Y )}, since the conditional entropies are non-negative. The equality

occurs iﬀ there exists a deterministic function f s.t. Y = f(X) or X = f(Y ) (so that either

H(Y |X) or H(X|Y ), respectively, is zero).

3. Properties for Markov Chains:

We introduce the notation X − Y − Z to reﬂect that

X and Z are conditionally independent given Y

⇔(X, Y, Z) is a Markov triplet

⇔p(x, z|y) = p(x|y)p(z|y)

⇔p(x|y, z) = p(x|y)

⇔p(z|y, x) = p(z|y)

For example, let X, W1, W2 be three independent Bernoulli random variables, with Y =

X ⊕ W1 and Z = Y ⊕ W2. Then, X and Z are conditionally independent given Y , i.e.,

X − Y − Z. Intuitively, Y is a noisy measurement of X, and Z is a noisy measurement of Y .

Since the noise variables W1 and W2 are independent, we only need Y to infer X.

We can also show that if X − Y − Z, then

(a) H(X|Y ) = H(X|Y, Z)

(b) H(Z|Y ) = H(Z|X, Y )

(c) H(X|Y ) ≤ H(X|Z)

(d) I(X; Y ) ≥ I(X; Z), and I(Y ; Z) ≥ I(X; Z)

Intuitively, X − Y − Z indicates that X and Y are more closely related than X and Z.

Therefore I(X; Y ) (i.e., the dependency between X and Y ) is no smaller than I(X; Z), and

H(X|Y ) (the uncertainty in X given knowledge Y ) is no greater than

EE376A COURSE NOTES

11


Chapter 3

Asymptotic Equipartition Properties

In this chapter, we will try to understand how the distribution of n-length sequences generated

by memoryless sources behave as we increase n. We observe that a set of small fraction of all

the possible n-length sequences occurs with probability almost equal to 1. Thus, this makes the

compression of n-length sequences easier as we can then concentrate on this set.

We begin by introducting some important notation:

• For a set S, |S| denotes its cardinality (number of elements contained on the set).

For

example, let U = {1, 2, . . . , M}, then |U| = M.

• un = (u1, . . . , un) is an n-tuple of u.

• Un = {un| ui ∈ U; i = 1, . . . , n}. It is easy to see that |Un| = |U|n.

• Ui generated by a memoryless source U" implies U1, U2, . . . i.i.d. according to U (or PU).

That is,

p(un) =

n

�

i=1

p(ui)

3.1

Asymptotic Equipartition Property (AEP)

Deﬁnition 12. The sequence un is ϵ-typical for a memoryless source U for ϵ &gt; 0, if

����− 1

n log p(un) − H(U)

���� ≤ ϵ

or equivalently,

2−n(H(U)+ϵ) ≤ p(un) ≤ 2−n(H(U)−ϵ)

Let A(n)

ϵ

denote the set of all ϵ-typical sequences, called the typical set.

So a length-n typical sequence would assume a probability approximately equal to 2−nH(U).

Note that this applies to memoryless sources, which will be the focus on this course1.

Theorem 13 (AEP). ∀ϵ &gt; 0, P

�

Un ∈ A(n)

ϵ

�

→ 1 as n → ∞.

1For a diﬀerent deﬁnition of typicality, see e.g. [1]. For treatment of non-memoryless sources, see e.g. [2], [3].

12


Proof

This is a direct application of the Law of Large Numbers (LLN).

P

�

Un ∈ A(n)

ϵ

�

= P

�����− 1

n log p(Un) − H(U)

���� ≤ ϵ

�

= P

������− 1

n log

n

�

i=1

p(Ui) − H(U)

����� ≤ ϵ

�

= P

������

1

n

� n

�

i=1

− log p(Ui)

�

− H(U)

����� ≤ ϵ

�

→ 1 as n → ∞

where the last step is due to the Law of Large Numbers (LLN), in which − log p(Ui)’s are i.i.d. and

hence their arithmetic average converges to their expectation H(U).

This theorem tells us that with very high probability, we will generate a typical sequence. But

how large is the typical set A(n)

ϵ

?

Theorem 14. ∀ϵ &gt; 0 and suﬃciently large n,

(1 − ϵ)2n(H(U)−ϵ) ≤

���A(n)

ϵ

��� ≤ 2n(H(U)+ϵ)

Proof

The upper bound:

1 ≥ P

�

Un ∈ A(n)

ϵ

�

=

�

un∈A(n)

ϵ

p(un) ≥

�

un∈A(n)

ϵ

2−n(H(U)+ϵ) =

���A(n)

ϵ

��� 2−n(H(U)+ϵ),

which gives the upper bound. For the lower bound, by the AEP theorem, for any ϵ &gt; 0, there

exists suﬃciently large n such that

1 − ϵ ≤ P

�

Un ∈ A(n)

ϵ

�

=

�

un∈A(n)

ϵ

p(un) ≤

�

un∈A(n)

ϵ

2−n(H(U)−ϵ) =

���A(n)

ϵ

��� 2−n(H(U)−ϵ).

The intuition is that since all typical sequences assume a probability about 2−nH(U) and their

total probability is almost 1, the size of the typical set has to be approximately 2nH(U). Although

���A(n)

ϵ

��� grows exponentially with n, notice that it is a relatively small set compared to Un. For some

ϵ &gt; 0, we have

���A(n)

ϵ

���

|Un| ≤ 2n(H(U)+ϵ)

2n log |U|

= 2−n(log |U|−H(U)−ϵ) → 0 as n → ∞

given that H(U) &lt; log |U| (with strict inequality!), i.e., the fraction that the typical set takes up

in the set of all sequences vanishes exponentially. Note that H(U) = log |U| only if the source is

uniformly distributed, in which case all the possible sequences are typical.

EE376A COURSE NOTES

13


The set Un of all sequences

A(n)

ϵ

P

�

Un ∈ A(n)

ϵ

�

≈ 1

un ∈ A(n)

ϵ

⇔ p(un) ≈ 2−nH(U)

���A(n)

ϵ

��� ≈ 2nH(U)

Figure 3.1: Summary of AEP

In the context of lossless compression of the source U, the AEP tells us that we may only focus

on the typical set, and we would need about nH(U) bits, or H(U) bits per symbol, for a good

representation of the typical sequences.

We know that the set, A(n)

ϵ

has probability 1 as n increases. However is it the smallest such

set? The next theorem gives a deﬁnitive answer to the question.

Theorem 15. For all δ &gt; 0 and all sequences of sets B(n) ⊆ Un such that

���B(n)��� ≤ 2n[H(U)−δ],

lim

n→∞ P

�

Un ∈ B(n)�

= 0

(3.1)

A visualization of Theorem 15 is shown in Figure 3.1.



Figure 3.2: Visualization of all source sequences and ε-typical sequences.

We can justify the theorem in the following way: As n increases |B(n) ∩ A(n)

ϵ

| ≈ 2−nδ|A(n)

ϵ

|.

As every typical sequence has probability of ≈ 2−nH(U), and is the same for every sequence,

P

�

Un ∈ B(n)�

= 0

We will next look at a simple application of the AEP for the compression of symbols generated

by a discrete memoryless source.

EE376A COURSE NOTES

14


3.2

Fixed Length (Near) Lossless Compression



Figure 3.3: Block Diagram for Losless Compression

Suppose we have a source U1, . . . , Un i.i.d. with distribution U. We wish to devise a compression

scheme, as shown in Figure 3.2. The compressor takes a block of n source symbols and converts

them into m binary bits. The decompressor does the inverse process. The rate of such a scheme

(compression and decompression) is deﬁned to be m

n bits/source symbol.

We relax our requirements slightly: rather than insisting on strictly lossless compression, we

will simply require the probability of error to be small. That is,

Pe = P

� ˆUn ̸= Un�

≪ 1

(3.2)

Deﬁnition 16 (Achievable rate). R is an achievable rate if for all ε &gt; 0, there exists a scheme (n,

m, compressor, decompressor) whose rate m

n ≤ R and whose probability of error Pe &lt; ε.

We are interested in the question: What is the lowest achievable rate? Theorems 17 and 18 tell

us the answer.

Theorem 17 (Direct theorem). For all R &gt; H(U), R is achievable.

Proof

Fix R &gt; H(U) and ε &gt; 0. Set δ = R −H(U) &gt; 0 and note that for all n suﬃciently large,

by Theorem 13,

P

�

Un /∈ A(n)

δ

�

&lt; ε,

(3.3)

and by Theorem 14,

���A(n)

δ

��� ≤ 2n[H(U)+δ] = 2nR.

(3.4)

Consider a scheme that enumerates sequences in A(n)

δ . That is, the compressor outputs a binary

representation of the index of Un if Un ∈ A(n)

δ ; otherwise, it outputs (0, 0, . . . , 0). The decompressor

maps this binary representation back to the corresponding sequence in A(n)

δ . For this scheme, the

probability of error is bounded by

Pe ≤ P

�

Un /∈ A(n)

δ

�

&lt; ε

(3.5)

and the rate is equal to

log

���A(n)

δ

���

n

≤ nR

n = R

(3.6)

Hence, R is an achievable rate.

Theorem 18 (Converse theorem). If R &lt; H(U), R is not achievable.

EE376A COURSE NOTES

15


Proof

For a given scheme of rate r ≤ R (and block length n), let B(n) denote the set of possible

reconstruction sequences ˆUn. Note that

���B(n)��� ≤ 2m = 2nr ≤ 2nR. So if R &lt; H(U), by Theorem 15,

Pe ≥ P

�

Un /∈ B(n)�

→ 1, as n → ∞

(3.7)

Hence, increasing n cannot make the probability of error arbitrarily small. Furthermore, there is

clearly a nonzero probability of error for any ﬁnite n, so R is not achievable. Conceptually, if the

rate is too small, it can’t represent a large enough set.

EE376A COURSE NOTES

16


Bibliography

[1] A. E. Gamal and Y.-H. Kim, Network Information Theory, Cambridge Univ. Press, UK, 2012.

[2] R. M. Gray, Entropy and Information Theory, Springer-Verlag, New York, 1990.

[3] T. S. Han, Information-Spectrum Methods in Information Theory, Springer, 2003.

17


Chapter 4

Lossless Compression

4.1

Uniquely decodable codes and preﬁx codes

Last lecture, we talked about how using the AEP, entropy emerges when you want to describe

source symbols in ﬁxed length at nearly lossless compression. In ﬁxed-length compression, you

map source sequences to representations 1:1. We also said that if you use variable length coding,

there is a way to achieve H bits/source symbol with perfect lossless compression, where H is the

entropy. How can we achieve such a code? The next few lectures will be devoted to that question.

Let us start with a simple code. Let l(u) represent the length of a binary codeword representing

u, u ∈ U. We can then write ¯l = El(u) = �

u∈U p(u)l(u) where ¯l is the expected length of a

codeword.

Example 19. Let U = {a, b, c, d} and let us try to come up with a simple code for this alphabet.



Figure 4.1: Code I

Note: here l(u) = − log p(u)

⇒ ¯l = E[l(u)] = E[− log p(u)] = H(u)

This code satisﬁes the preﬁx condition since no codeword is the preﬁx for another codeword. It

also looks like the expected code length is equal to the entropy. Is the entropy the limit for variable

length coding? Can we do better? Let us try a better code.

Here is a "better" code, where ¯l &lt; H

However, the code in Figure 4.2 is not uniquely decodable. For instance, both ’abd’ and ’cbb’ can

be represented by the code 0111. These codes are not useful. This motivates the notion of uniquely

decodable schemes.

18




Figure 4.2: Better code with regard to l(u)

Deﬁnition 20. A code is uniquely decodable(UD) if every sequence of source symbols is mapped to

a distinct binary codeword.

Deﬁnition 21.

Preﬁx Condition: When no codeword is the preﬁx of any other.

Preﬁx Code: A code satisfying the preﬁx condition.

Codes that satisfy the preﬁx condition are decodable on the ﬂy. Codes that do not satisfy the

preﬁx condition can also be uniquely decodable, but they are less useful.

Exercise 22. Consider Code II in Figure 4.3



Figure 4.3: Code II

Prove that this code is UD.

Let us construct binary trees to represent codes. Here, the terminal nodes represent source symbols,

and the path from the root to each terminal node represents the codeword for that source symbol.

We can construct binary trees for all UD codes, as we will see later.

Here are Binary trees for Code I and Code II:

From here on, let us restrict our attention to preﬁx codes. In fact, we will see that for any

non-preﬁx code with a given expected code length, we can always ﬁnd a preﬁx code with at least

as small of a code length.

EE376A COURSE NOTES

19




Figure 4.4: Binary tree for Code I



Figure 4.5: Binary tree for Code II

4.2

Preﬁx code for dyadic distributions

We would like to systematically construct uniquely decodable preﬁx codes for any alphabet with

arbitrary probability mass functions. We will start with dyadic distributions.

Deﬁnition 23. A dyadic distribution has p(u) = 2−nu, ∀u ∈ U, where nu are integers. (∗)

Note: If we ﬁnd a UD code with l(u) = nu = − log p(u), then ¯l = H.

We claim that we can always ﬁnd a UD code for a dyadic distribution.

Lemma 24. Assume (∗) and nmax = maxu∈U nu, considering that we have a nontrivial distribution

(where p(u) is not 1 at one value and 0 everywhere else). The number of symbols u with nu = nmax

is even.

Proof

1 =

�

u∈U

p(u)

=

�

u∈U

2−nu

=

nmax

�

n=1

(# of symbols u with nu = n) · 2−n

⇒ 2nmax =

nmax

�

n=1

(# of symbols u with nu = n) · 2nmax−n

=

nmax−1

�

n=1

(# of symbols u with nu = n) · 2nmax−n + (# of symbols u with nu = nmax)

(4.1)

EE376A COURSE NOTES

20


Since all terms except (# of symbols u with nu = nmax) are even, the number of elements in the

alphabet with the smallest probability has to be even.

Now with this lemma in hand, we can prove our claim that we can ﬁnd a UD code for a dyadic

distribution. Consider the following procedure:

• Choose 2 symbols with nu = nmax and merge them into one symbol with (twice the) proba-

bility 2−nmax+1

• The new source distribution is also dyadic.

• Repeat the procedure until left with one symbol.

Note: This procedure induces a binary tree.

E.g.:



Figure 4.6: Induced binary tree using the procedure

Also note that the symbol with p(u) = 2−nu has distance nu from root. This means that the

induced preﬁx code satisﬁes l(u) = nu = − log p(u)

4.3

Shannon codes

How can we get a good code for a non-dyadic distribution? We can attempt to use the above

principles. Let us look for a code with

l(u) = ⌈− log p(u)⌉ = n∗

u

∀u ∈ U

Here, we take the ceiling of − log p(u) as the length of the codeword for the source symbol u. Be-

cause the ceiling of a number is always within 1 of the actual number, the expected code length

¯l = E[− log p(u)] is within 1 of H(u).

Let us consider the "PMF" p∗(u) = 2−n∗

u. This "PMF" is a dyadic distribution because all

probabilities are a power of 2. We put PMF in quotes because for a non-dyadic source, �p∗(u)

u∈U is

less than 1, and so the PMF is not a true PMF. See the following:

�

u∈U

p∗(u) =

�

u∈U

2−n∗

u =

�

u∈U

2−⌈− log p(u)⌉

&lt;

�

u∈U

2−(− log p(u)) = 1

(4.2)

EE376A COURSE NOTES

21


To make it a true PMF, let us add ﬁctitious source symbols so that U∗ ⊇ U and �

u∈U∗ p∗(u) = 1.

We can thus construct a preﬁx code for U∗. Because this is a dyadic distribution, we can use the

binary tree principle above to construct a code for all u ∈ U∗, and we can consider only the source

symbols u in the original alphabet U. The lengths of each codeword will satisfy

l(u) = − log p∗(u) = n∗

u = ⌈− log p(u)⌉

∀u ∈ U

The expected code length for a Shannon code can be expressed as the following:

¯l = �

u p(u)l(u) = �

u p(u)⌈− log p(u)⌉ ≤ �

u p(u)(− log p(u) + 1) = H(U) + 1

Therefore, the expected code length is always less or equal to the entropy plus 1.

This result

could be good or bad depending on how large H(U) is to start with. If the extra “1" is too much,

alternatively, we can construct a Shannon code for the multi-symbol un = (u1, u2, ...un), where ui

is memoryless. Then,

¯ln ≤ H(Un) + 1 or 1

n¯ln ≤ 1

nH(Un) + 1

n = H(U) + 1

n

Now we can make it arbitrarily close to the entropy. In the end, there is a trade-oﬀ between ideal

code length and memory since the code map is essentially a lookup table. If n gets too large, the

exponential increase in lookup table size could be a problem.

4.4

Average codelength bound for uniquely decodable codes

We looked at a way of obtaining a preﬁx code for any given distribution. We will now try to

understand the bounds on the average codelength for any generic uniquely decodable code for a

distribution.

Theorem 25 (Kraft-McMillan Inequality). For all uniquely decodable (UD) codes,

�

u∈U

2−ℓ(u) ≤ 1

(4.3)

Conversely, any integer-valued function satisfying (4.3) is the length function of some UD code.

To see the “conversely" statement, note that we know how to generate a UD code (in fact, a

preﬁx code) with length function satisfying (4.3), using Huﬀman Codes. Here, we prove the ﬁrst

claim of the Kraft-McMillan Inequality.

EE376A COURSE NOTES

22


Proof

Take any UD code and let ℓmax = maxu ℓ(u). Fix any integer k and note the following.

��

u∈U

2−ℓ(u)

�k

= (

�

u1

2−ℓ(u1)) · (

�

u2

2−ℓ(u2)) · . . . · (

�

uk

2−ℓ(uk))

=

�

u1

�

u2

. . .

�

uk

k

�

i=1

2−ℓ(ui)

=

�

(u1,...,uk)

2−�k

i=1 ℓ(ui)

=

�

uk

2−ℓ(uk)

=

k·ℓmax

�

i=1

���

�

uk �� ℓ(uk) = i

���� · 2−i

≤

k·ℓmax

�

i=1

2i · 2−i

= k · ℓmax

Note that the inequality in the second to last line arises because we know that our code is one-to-

one so there can be at most 2i symbols whose codewords have length i. Finally, we can see the

theorem through the following inequality.

�

u

2−ℓ(u) ≤

lim

k→+∞(kℓmax)1/k = 1

Now, we can prove the important theorem relating UD codes to the binary entropy.

Theorem 26. For all UD codes, ℓ ≥ H(U)

Proof

Consider, H(U) − ℓ = H(U) − Eℓ(U)

= E

�

log

1

p(U) − ℓ(U)

�

= E

�

log 2−ℓ(U)

p(U)

�

≤ log E

�

2−ℓ(U)

p(U)

�

= log

�

u

2−ℓ(u) ≤ log 1 = 0

EE376A COURSE NOTES

23


Note that we used the earlier proved Kraft-McMillan Inequality for UD codes in the proof.

As an aside, suppose ℓ(u) = − log q(u) for some pmf q. Then,

ℓ − H = E[ℓ(U) − log

1

p(u)]

=

�

u

p(u) log p(u)

q(u)

= D(p∥q)

Thus, D(p∥q) can be thought of as the “cost of mismatch", in designing a code for a distribution

q, when the actual distribution is p.

4.5

Huﬀman Coding

We earlier looked at Shannon code, which is a pretty good construction of a preﬁx code for a given

distribution. However, the best preﬁx code for a general source code distribution is the Huﬀman

Code.

The construction of the huﬀman code follows is very similar to that of the dyadic code. To ﬁnd

the code c(u), we follow these steps:

1. Find 2 symbols with the smallest probability and then merge them to create a new “node"

and treat it as a new symbol.

2. Then merge the next 2 symbols with the smallest probability to create a new “node"

3. Repeat steps 1 and 2 until there is only 1 symbol left. At this point, we created a binary tree.

The paths traversed from the root to the leaves are the preﬁx codes.

We consider an example of huﬀman code construction:

Example 27. Preﬁx code for a senary source (six letters) is given below:

e

f

d

a

b

c

1

2

3

4

5

p=0.15

p=0.3

p=0.55

p=0.45

1

1

1

1

1

0

0

0

0

0

u p(u) c(u) l(u)

e

0.1

1110

4

f

0.05 1111

4

d 0.15

110

3

a 0.25

10

2

b

0.2

00

2

c

0.2

01

2

We will next try to understand why Huﬀman codes are the optimal preﬁx codes.

EE376A COURSE NOTES

24


4.6

Optimality of Huﬀman codes

Suppose we have a random object U ∼ P with alphabet U = {1, 2, . . . , r}. We let c(u), ℓ(u) be

the codeword and length associated with some u ∈ U, respectively. Recall, the average length is

denoted as ℓ = Eℓ(U). Assume, WLOG, that the symbols in U are ordered in decreasing order of

probability according to p, i.e. p(1) ≥ p(2) ≥ · · · ≥ p(r). Let Ur−1 denote a random variable over

Ur−1 = {1, 2, . . . , r − 1} and

p(Ur−1 = i) =

�

p(i)

1 ≤ i ≤ r − 2

p(r − 1) + p(r)

i = r − 1

and cr−1(ur−1), ℓr−1(ur−1) are the codeword and length of ur−1 ∈ Ur−1, respectively.

Again,

ℓr−1 = Eℓr−1(Ur−1).

"Splitting a preﬁx code cr−1": creating a preﬁx code for U by















c(i) = cr−1(i)

1 ≤ i ≤ r − 2

c(r − 1) = cr−1(r − 1)0

c(r) = cr−1(r − 1)1

We will use the following lemma to justify the optimality of Huﬀman Codes. Intuitively, we

will show that if we start with an optimal code on r −1 symbols, splitting gives us an optimal code

over r symbols. We can use an inductive argument, starting with a binary object to prove that

Huﬀman Codes are optimal for alphabets with any number of symbols.

Lemma 28. Let copt,r−1 be an optimal preﬁx code for Ur−1. Let c be the code obtained from copt,r−1

by splitting. Then c is an optimal preﬁx code for U.

Proof

Note there is an optimal preﬁx code for U satisfying:

1. ℓ(1) ≤ ℓ(2) ≤ . . . ≤ ℓ(r) Otherwise, we could rearrange the codes to satisfy this property, and

the result would be at least as good due to the ordergin we have assumed on the probabilities.

2. ℓ(r − 1) = ℓ(r) = ℓmax

Suppose in an optimal code the two longest codewords were not of the same length. Since

the preﬁx property holds, no codeword is a preﬁx of the longest codeword.

The longest

codeword can be truncated, preserving the preﬁx property but achieving lower expected

codeword length. Since the code was optimal, this leads to a contradiction, so the two longest

codewords must be of the same length.

3. c(r − 1) and c(r) diﬀer only in the last bit

Given any optimal code, rearranging the code can result in a code with this property. Suppose

there is a codeword of maximal length such that it does not have a ‘sibling’. The last bit of this

codeword can be deleted, preserving the preﬁx property but achieving lower expeted codeword

length. This leads to a contradiction, so every codeword of maximal length must have a

‘sibling’ in an optimal code. By rearranging the assignments of the maximal length codewords,

we can ensure that the two least likely symbols are assigned a pair of sibling codewords. This

rearrangement maintains the expected codeword length, and achieves property.

EE376A COURSE NOTES

25


Note, by the second and third properties, there is an optimal preﬁx code for U that is the result of

splitting a preﬁx code for Ur−1 (where the code for Ur−1 can be seen as our original code with the

the codeword c(r − 1) is truncated before the ﬁnal bit). Let ℓr−1 be the length function of a preﬁx

code for Ur−1 and ℓ be the length function of a preﬁx code for U obtained by splitting Ur−1. Then

ℓ =

r

�

i=1

p(i)l(i)

=

r−2

�

i=1

p(i)l(i) + p(r − 1)l(r − 1) + p(r)l(r)

=

r−2

�

i=1

p(Ur−1 = i)lr−1(i) + (p(r − 1) + p(r))l(r − 1)

=

r−2

�

i=1

p(Ur−1 = i)lr−1(i) + (p(r − 1) + p(r))(lr−1(r − 1) + 1)

=

r−2

�

i=1

p(Ur−1 = i)lr−1(i) + p(Ur−1 = r − 1)lr−1(r − 1) + (p(r − 1) + p(r))

=

r−1

�

i=1

p(Ur−1 = i)lr−1(i) + (p(r − 1) + p(r))

= ℓr−1 + p(r − 1) + p(r)

ℓ = ℓr−1 + p(r − 1) + p(r)

because the expectation sums diﬀer only in the ﬁnal two terms, where an additional bit is added

for symbols r − 1 and r. We can see, by this simple relationship, that if we want to optimize ℓ for

some ﬁxed probability distribution, it suﬃces to optimize ℓr−1. So if ℓr−1 is optimal, then so is ℓ.

Thus, we have that an optimal preﬁx code for U is obtained by splitting an optimal preﬁx code for

Ur−1.

EE376A COURSE NOTES

26


Bibliography

[1] D. J. C. MacKay, Information Theory, Inference, and Learning Algorithms, Cambridge Uni-

versity Press, UK, 2003.

[2] S. Geman and D. Geman, “Stochastic Relaxation, Gibbs Distributions, and the Bayesian

Restoration of Images,” IEEE Trans. on Pattern Analysis and Machine Intelligence, vol. 6,

pp. 721–741, 1984.

27


Chapter 5

Communication and Channel

Capacity

5.1

The Communication Problem

We model communication as the transmission of an input consisting of n symbols (denoted Xn)

through a noisy channel. This channel will emit an output of n symbols (denoted Y n). Think of

the channel as corrupting or adding noise to the input.

The behavior of the channel is characterized by the conditional probability distribution PY n|Xn,

which tells us the distribution over the outputs that it will emit for any given input.

Conceptually, we have the following picture:

Xn −→

noisy channel

PY n|Xn

−→ Y n

Our goal, then, is to ﬁnd an encoder e and a decoder d such that we can take an input of m

bits (called Bm), encode it using e to get an encoding of length n denoted Xn, pass the encoding

through the channel to get Y n, and then decode Y n using d to recover an estimate of the original

string of bits, denoted ˆBm. Pictorially, that is:

(B1, B2, . . . , Bm) = Bm −→ encoder (e)

Xn

−→

noisy channel

PY n|Xn

Y n

−→ decoder (d) −→ ˆBm = ( ˆB1, ˆB2, . . . , ˆBm)

Ideally, n will be small relative to m (we will not have to send a lot of symbols through the noisy

channel), and the probability that the received message ˆBm does not match the original message

Bm will be low. We will now make rigorous these intuitively good properties.

Deﬁnition 29. We deﬁne a scheme to be a pair of encoder and decoder, denoted (e, d).

Note that the deﬁnition of a scheme does not include the noisy channel itself. We must take the

channel as it is given to us: we cannot modify it, but we can choose what symbols Xn to transmit

through it.

28


Deﬁnition 30. We deﬁne the rate of a scheme, denoted R, to be the number of bits communicated

per use of the channel. This is equal to m/n in the notation of the diagram above.

Deﬁnition 31. We deﬁne the probability of error for a scheme, denoted Pe, to be the probability

that the output of the decoder does not exactly match the input of the encoder. That is,

Pe = P(Bm ̸= ˆBm).

Deﬁnition 32. For a given channel, we say that a rate R is achievable if there exists a sequence

of schemes (e1, d1), (e2, d2), . . ., such that:

1. For all n = 1, 2, . . ., scheme (en, dn) has rate at least R, and

2.

lim

n→∞ P (n)

e

= 0,

where P (n)

e

denotes the probability of error of the nth scheme.

5.2

Channel Capacity

We want to know what the best possible performance is under a particular noisy channel. This is

essentially what channel capacity tells us.

Deﬁnition 33. For a given channel, the channel capacity (denoted C) is the theoretical limit on the

number of bits that can be reliably communicated (i.e., communicated with arbitrarily low probability

of error) in one channel use.

That is,

C := sup{R : R is achievable}

We assume a "memoryless channel": PY n|Xn(yn|xn) =

n

�

i=1

PY |X(yi|xi) exhibiting a "single letter

channel" characteristic of output symbol given input symbol. Restated, the i-th channel output

only cares about the ith channel input.

X ∼ Px −→ PY |X −→ random Y

With this single letter channel, we now examine I(X; Y ). What distribution of X will maximize

I(X; Y ) over all possible channel inputs?

C(I) ≜ max

PX I(X; Y )

Theorem 34. Channel Coding Theorem:

C = C(I) = max

X

I(X; Y ) (sometimes written as

max

PX )

Proof:

Direct Theorem: If R &lt; C(I), then the rate R is achievable.

Converse Theorem: If R &gt; C(I), then R is not achievable.

The direct part and the converse part of the proof are given at the end of this chapter.

EE376A COURSE NOTES

29


5.2.1

Channel Capacity of various discrete channels

Example 35. Binary Symmetric Channel (BSC)

Let: X = Y = {0, 1}

and the crossover probability be

PY |X(y|x) =

�

p

y ̸= x

1 − p

y = x

⇐⇒ channel matrix:

0

1

0

1 − p

p

1

p

1 − p

⇐⇒ bipartite graph:

0

1

0

1

1−p

p

p

1−p

⇐⇒ Y = X ⊕2 Z ← ber(p)

To compute the capacity of the BSC, we ﬁrst examine mutual information

I(X; Y ) = H(Y ) − H(Y |X)

deﬁnition of mutual information

= H(Y ) − H(X ⊕2 Z|X)

substitute Y with X ⊕2 Z

= H(Y ) − H(Z)

given X, X ⊕2 Z is simply Z

= H(Y ) − h2(p) ≤ 1 − h2(p)

h2(p) is binary entropy

To achieve equality, H(Y ) = 1, i.e. Y is bernoulli 1

2. Taking X ∼ Ber(1

2) produces this desired Y

and therefore gives I(X; Y ) = 1 − h2(p)

=⇒ C = 1 − h2(p)

(1 − h2(p))n bits of information can be communicated reliably.

Example 36. Binary Symmetric Channel (BEC)

Let: X = {0, 1}, Y = 0, 1, e

and the crossover probability be

PY |X(y|x) =

�

α

y = e

1 − α

y = x

EE376A COURSE NOTES

30


0

1

0

e

1

1−α

α

α

1−α

I(X; Y ) = H(X) − H(X|Y )

= H(X) − [H(X|Y = e)P(Y = e) + H(X|Y = 0)P(Y = 0) + H(X|Y = 1)P(Y = 1)]

= H(X) − [H(Xα + 0 + 0]

= (1 − α)H(x)

To achieve equality, H(X) = 1, i.e. X is bernoulli 1

2.

I(X; Y ) = 1 − α

=⇒ C = 1 − α

(1 − α)n bits of information can be communicated reliably.

5.2.2

Recap

Encoder/

Transmitter

Noisy

Memoryless

Channel

Decoder/

Receiver

J

⇐⇒

B1, B2, ..., Bm

i.i.d. ∼Ber(1/2)

Xn

Y n

ˆJ ⇐⇒

ˆB1, ˆB2, ..., ˆBm

• Rate = m

n

bits

channel use

• Pe = P( ˆJ ̸= J)

• R is achievable if ∀ ϵ &gt; 0,

∃ a scheme (m, n, encoder, decoder) with m

n ≥ R and Pe &lt; ϵ.

• Capacity: C = sup{R: R is achievable}.

• Channel Coding Theorem: C = maxX I(X; Y ).

Note:

The Channel Coding Theorem is equally valid for analog signals, e.g., the AWGN chan-

nel. However, we must extend our deﬁnition of the various information measures such as entropy,

mutual information, etc.

Next we extend the information measures to continue random variables, and analyze the AWGN

channel.

EE376A COURSE NOTES

31


5.3

Information Measures for Continuous Random Variables

In this chapter we extend the information measures to continues random variables.

Deﬁnition 37. Relative Entropy for two PDFs f and g, is deﬁned as

D(f||g) =

�

f(x) log f(x)

g(x) dx,

x ∈ R.

Can similarly deﬁne for x ∈ Rn.

Note: When integral on the right hand side is not well deﬁned, D(f||g) = ∞

Deﬁnition 38. Mutual Information between two continuous r.v. X, Y with joint pdf fX,Y (i.e.,

X, Y ∼ fX,Y ) is

I(X; Y ) = D(fX,Y ||fX · fY )

=

� �

fX,Y (x, y) log fX,Y (x, y)

fX(x)fY (y)dxdy,

where fX × fY is the product of the marginal distributions.

Deﬁnition 39. Diﬀerential entropy of

1. X ∼ fX:

h(x) ≜ E[− log fX(x)]

2. X, Y ∼ fX,Y :

h(X, Y ) ≜ E[− log fX,Y (X, Y )]

(“Joint Diﬀerential Entropy”)

h(X|Y ) ≜ E[− log fX|Y (X|Y )]

(“Conditional Diﬀerential Entropy”)

Each of the above deﬁnitions is totally analogous to the discrete case.

In the homework we will show the following result:

I(X; Y ) = h(X) + h(Y ) − h(X, Y )

= h(X) − h(X|Y )

= h(Y ) − h(Y |X)

This is the main/only interest in diﬀerential entropy.

Note:

Unlike discrete entropy H(X), diﬀerential entropy can be positive or negative. This is not

the only way in which they diﬀer.

h(X + c) = h(X),

for constant c

h(X · c) = h(X) + log |c|,

c ̸= 0

EE376A COURSE NOTES

32


5.3.1

Examples

Example 40.

X ∼ U[a, b]

fX(x) =

�

1

b−a

a ≤ x ≤ b

0

otherwise

h(x) = log(b − a)

Example 41.

X ∼ N(0, σ2), f(x) =

1

√

2πσ2 e

−x2

2σ2

h(x) = E

�

− log

1

√

2πσ2 + x2/2σ2

ln 2

�

= 1

2 log 2πσ2 + σ2/2σ2

ln 2

= 1

2 log 2πσ2 +

1

2 ln 2

= 1

2

�

log 2πσ2 + log e

log 2

�

= 1

2

�

log 2πσ2 + log e

�

= 1

2 log(2πσ2e)

Note: diﬀerential entropies can be either positive or negative. The more correlated the random

variable the more negative

Example 42. Signiﬁcance of Diﬀerential entropy

Many Information theorists would argue none whatsoever. However, some others oﬀer a diﬀerent

perspective.

If you discretize X ∼ f into X∆ with time period ∆,

P(x∆ = i) =

� i∆+∆/2

i∆−∆/2

f(x)dx ≈ f(i∆) · ∆

H(X∆) =

�

i

Pi log 1

P1

≈

�

i

f(i∆) · ∆ · log

1

∆f(i∆)

= log 1

∆ +

�

i

�

f(i∆) log

1

f(i∆)

�

∆

H(X∆) − log 1

∆ =

�

i

f(i∆) log

1

f(i∆)∆ ∆→0

−−−→

�

f(x) log

1

f(x)dx = h(x)

EE376A COURSE NOTES

33


=⇒ H(X∆) ≈ log 1

∆ + h(x)

Majority of the entropy for discretized system is accounted for with log 1

∆. The rest of it is h(x)

the diﬀerential entropy

5.3.2

Gaussian Distribution

Claim: The Gaussian distribution has maximal diﬀerential entropy, i.e.,:

If X ∼ fX with E[X2] ≤ σ2 (second moment), and G ∼ N(0, σ2),

Then h(X) ≤ h(G), with equality iﬀ X ∼ N(0, σ2).

Note:

If E[X2] ≤ σ2 and V ar(X) = σ2, then necessarily E[X] = 0.

Proof of Claim:

fG(X) =

1

√

2πσ2 e−

1

2σ2 X2,

− log fG(X) = log

√

2πσ2 +

1

2σ2 X2

ln 2

0 ≤ D(fX||fG) = E

�

log fX(X)

fG(X)

�

= −h(X) + E

�

log

1

fG(X)

�

= −h(X) + E

�

log

√

2πσ2 +

1

2σ2 X2

ln 2

�

≤ −h(X) + E

�

log

√

2πσ2 +

1

2σ2 G2

ln 2

�

= −h(X) + E

�

log

1

fG(G)

�

= −h(X) + h(G)

∴ h(X) ≤ h(G), with equality iﬀ D(fX||fG) = 0, i.e., X ∼ G

5.4

Channel Capacity of the AWGN Channel (Additive White

Gaussian Noise)

Xi

+

Wi

Yi

EE376A COURSE NOTES

34


Note:

The AWGN channel is memoryless.

• Transmission is restricted to power P:

1

n

n

�

i=1

X2

i ≤ P,

∀n ∈ N

• R is achievable with power P if: ∀ ϵ &gt; 0,

∃ scheme restricted to power P and with rate

m

n ≥ R and probability of error Pe &lt; ϵ.

• Channel Capacity: C(P) = sup{R: R is achievable with power P}

5.4.1

Channel Coding Theorem for this Setting

C(P) =

max

E[X2]≤P I(X; Y )

Note:

We could instead have considered the restriction that E[ 1

n

�n

i=1 X2

i ] ≤ P. This constitutes

a relaxed constraint. However, it turns out that even with the relaxation, you cannot perform any

better in terms of the fundamental limit.

5.4.2

An Aside: Cost Constraint

More generally, we can consider an arbitrary cost function constraint on X, rather than the

above power constraint. We can denote this cost function by φ(Xi). The cost constraint is then

1

n

�n

i=1 φ(Xi) ≤ α. This means that the average cost cannot exceed the core parameter α, so we

consider C(α). In this case, the coding theorem becomes C(α) = maxE[φ(X)]≤α I(X; Y ).

5.4.3

The Example

X

E[X2] ≤ P

+

W ∼ N(0, σ2)

Y

EE376A COURSE NOTES

35


I(X; Y ) = h(Y ) − h(Y |X)

= h(Y ) − h(Y − X|X)

(given X, X is a constant, so we can use invariance

of diﬀerential entropy to constant shifts)

= h(Y ) − h(W|X)

= h(Y ) − h(W)

(since W and X are independent)

≤ h(N(0, P + σ2)) − h(N(0, σ2))

(V ar(Y ) = V ar(X + W) = V ar(X) + V ar(W) ≤ P + σ2)

= 1

2 log 2πe(P + σ2) − 1

22πeσ2

= 1

2 log P + σ2

σ2

= 1

2 log

�

1 + P

σ2

�

So in conclusion,

I(X; Y ) ≤ 1

2log

�

1 + P

σ2

�

with equality

⇐⇒

Y ∼ N(0, P + σ2)

⇐⇒

X ∼ N(0, P)

Therefore, equality is achievable. So,

C(P) = 1

2 log

�

1 + P

σ2

�

(i.e., the capacity of the AWGN channel.)

5.4.4

Rough Geometric Interpretation (Picture)

• Transmission Power Constraint:

��n

i=1 X2

i ≤ √np

• Noise:

��n

i=1 W 2

i ≈

√

nσ2

• Channel Output Signal:

E

� n

�

i=1

Y 2

i

�

= E

� n

�

i=1

(Xi + Wi)2

�

= E

� n

�

i=1

X2

i +

n

�

i=1

W 2

i

�

(independence ⇒ cross-terms have zero expectation)

≤ nP + nσ2

= n(P + σ2)

EE376A COURSE NOTES

36




Figure 5.1: Geometrically, consider the input and output sequences as points in Rn.

See Figure 7.2 for the geometric interpretation of this problem. We want the high probability

output balls to not intersect. This way, we can uniquely distinguish the input sequences associated

with any given output sequence.

# messages ≤ Vol(n-dim ball of radius

�

n(P + σ2))

Vol(n-dim ball of radius

√

nσ2)

This inequality is due to ineﬃciencies in the packing ratio. Equality corresponds to perfect

packing, i.e. no dead-zones. So,

# of bits = Kn(

�

n(P + σ2))n

Kn(

√

nσ2)n

=

�

1 + P

σ2

�n/2

⇒ rate = log # of messages

n

≤ 1

2 log

�

1 + P

Q

�

The achievability of the equality indicates that in high dimension, can pack the balls very

eﬀectively.

EE376A COURSE NOTES

37


5.5

Joint Asymptotic Equipartition Property (AEP)

Let X, Y be jointly random variables with alphabets X, Y, respectively. Let the source be memo-

ryless so that (Xi, Yi) are i.i.d. ∼ PX,Y . That is,

P(xn) =

n

�

i=1

PX(xi),

P(yn) =

n

�

i=1

PY (yi),

P(Xn, Y n) =

n

�

i=1

PX,Y (xi, yi)

(5.1)

5.5.1

Set of Jointly Typical Sequences

Let A(n)

ϵ

(X, Y ) denote the set of jointly typical sequences. That is,

A(n)

ϵ

(X, Y ) = {(Xn, Y n) : | − 1

n log P(xn) − H(X)| &lt; ϵ,

(5.2)

| − 1

n log P(yn) − H(Y )| &lt; ϵ,

(5.3)

| − 1

n log P(xn, yn) − H(X, Y )| &lt; ϵ}

(5.4)

Theorem 43. If (Xn, Y n) are formed by i.i.d. (Xi, Yi) ∼ PX,Y , then

1.

lim

n→∞ P((Xn, Y n) ∈ A(n)

ϵ

(X, Y )) = 1

(5.5)

By the AEP, we have that Xn is typical, Y n is typical, and (Xn, Y n) is typical too.

2. ∀ϵ &gt; 0, ∃n0 ∈ N such that ∀n &gt; n0

(1 − ϵ)2n(H(X,Y )−ϵ) ≤ |A(n)

ϵ

(X, Y )| ≤ 2n(H(X,Y )+ϵ)

(5.6)

Theorem 44. If ( ˜Xn, ˜Y n) are formed by i.i.d. ( ˜Xi, ˜Yi) ∼ ( ˜X, ˜Y ), where P ˜

X, ˜Y = PX · PY , then

∀ϵ &gt; 0, ∃n0 ∈ N such that ∀n &gt; n0

(1 − ϵ)2−n(I(X;Y )+3ϵ) ≤ P(( ˜Xn, ˜Y n) ∈ A(n)

ϵ

(X, Y )) ≤ 2−n(I(X;Y )−3ϵ)

(5.7)

Intuition:

|A(n)

ϵ

( ˜X, ˜Y )| ≈ 2nH( ˜

X, ˜Y )

(5.8)

= 2n(H(X)+H(Y ))

(5.9)

= 2nH(X) · 2nH(Y )

(5.10)

≈ |A(n)

ϵ

(X)| · |A(n)

ϵ

(Y )|

(5.11)

Note that ( ˜X, ˜Y ) are distributed uniformly within a set of size |A(n)

ϵ

(X)| · |A(n)

ϵ

(Y )|

⇒ P(( ˜Xn, ˜Y n) ∈ A(n)

ϵ

(X, Y )) =

|A(n)

ϵ

(X, Y )|

|A(n)

ϵ

(X)| · |A(n)

ϵ

(Y )|

(5.12)

≈

2nH(X,Y )

2nH(X) · 2nH(Y )

(5.13)

= 2−nI(X;Y )

(5.14)

EE376A COURSE NOTES

38


Proof:

P(( ˜Xn, ˜Y n) ∈ A(n)

ϵ

(X, Y )) =

�

(˜xn,˜yn)∈A(n)

ϵ

(X,Y )

P(˜xn) · P(˜yn)

(5.15)

≤

�

(˜xn,˜yn)∈A(n)

ϵ

(X,Y )

2−n(H(X)−ϵ) · 2−n(H(Y )−ϵ)

(5.16)

= |A(n)

ϵ

(X, Y )| · 2−n(H(X)+H(Y )−2ϵ)

(5.17)

≤ 2n(H(X,Y )−ϵ) · 2−n(H(X)+H(Y )−2ϵ)

(5.18)

≤ 2n(H(X,Y )−H(X)−H(Y )−3ϵ)

(5.19)

= 2−nI(X;Y )−3ϵ

(5.20)

5.6

Direct Theorem

Recall the setting under consideration:

Encoder/

Transmitter

Memoryless Channel

P(Y |X)

Decoder/

Receiver

J

⇐⇒ B1, B2, . . . , BM

i.i.d. ∼Bern(1/2)

Xn

Y n

ˆJ ⇐⇒ ˆB1, ˆB2, . . . , ˆBM

J is uniformly distributed on {1, 2, . . . , M}. We deﬁne our scheme as follows:

Encoder (also known as “codebook”): {1, 2, . . . , M} → Xn.

That is, codebook cn = {Xn(1), Xn(2), . . . , Xn(M)}

Decoder: ˆJ(·) : Y n → {1, 2, . . . , M}

Rate: Bits per channel use = log(M)/n = log(|cn|)/n

Theorem 45. (Direct Theorem) If R &lt; maxPX I(X; Y ), then R is achievable. Equivalently, if

∃ PX

s.t.

R &lt; I(X; Y ), then R is achievable.

Proof

Fix PX and a rate R &lt; I(X; Y ). Choose ϵ = (I(X; Y )−R)/4. This means that R &lt; I(X; Y )−3ϵ.

Generate codebook Cn of size M = ⌈2nR⌉.

Xn(k) are i.i.d. with distribution PX, ∀ k = 1, 2, . . . , M. Then

ˆJ(Y n) =

�

j

if

(Xn(j), Y n) ∈ An

ϵ (X, Y )

and

(Xn(k), Y n) /∈ An

ϵ (X, Y ), ∀j ̸= k

error

otherwise

(5.21)

EE376A COURSE NOTES

39


Denote probability of error using a codebook cn as Pe(cn). Thus, Pe(cn) = P( ˆJ ̸= J|Cn = cn)

E[Pe(Cn)] = P( ˆJ ̸= J)

(5.22)

=

M

�

i=1

P( ˆJ ̸= J|J = i)P(J = i)

(5.23)

= P( ˆJ = J|J = 1)

(5.24)

This follows because, by symmetry, P( ˆJ ̸= J|J = i) = P( ˆJ ̸= J|J = j), ∀i, j, and P(J = i) =

1/M, ∀i

By union bound, it follows that

P( ˆJ ̸= J|J = 1)

≤ P((Xn(1), Y n) /∈ A(n)

ϵ

(X, Y )) +

M

�

k=2

P((Xn(k), Y n) ∈ A(n)

ϵ

(X, Y ))

The ﬁrst term on the right tends to zero as n tends to inﬁnity. Therefore,

P( ˆJ ̸= J|J = 1) ≤

M

�

k=2

P((Xn(k), Y n) ∈ A(n)

ϵ

(X, Y ))

(5.25)

≤

M

�

k=2

P(( ˜Xn, ˜Y n) ∈ A(n)

ϵ

(X, Y ))

(5.26)

≤ (M − 1) · 2−n(I(X;Y )−3ϵ)

(5.27)

≤ 2nR · 2−n(I(X;Y )−3ϵ)

(5.28)

≤ 2−n(I(X;Y )−3ϵ−R)

(5.29)

Since R &lt; I(X; Y ) − 3ϵ, the expression tends to zero as n tends to inﬁnity.

This means that,

∃cn s.t. |cn| ≥ 2nR

and

Pe(cn) ≤ E[Pe(Cn)]

⇒ ∃cn s.t. |cn| ≥ 2nR

and

limn→∞ Pe(cn) = 0

⇒ R is achievable.

5.7

Fano’s Inequality

Theorem 46 (Fano’s Inequality). Let X be a discrete random variable and ˆX = ˆX(Y ) be a guess

of X based on Y . Let Pe := P( ˆX ̸= X). Then H(X|Y ) ≤ h(Pe) + Pe log(|X| − 1).

EE376A COURSE NOTES

40


Proof

Let V = 1{ ˆ

X̸=X}.

H(X|Y )

≤

H(X, V |Y )

(Data Processing Inequality)

(5.30)

=

H(V |Y ) + H(X|V, Y )

(Chain Rule)

(5.31)

≤

H(V ) + H(X|V = 0, Y = y)P(V = 0, Y = y)

+H(X|V = 1, Y = y)P(V = 1, Y = y)

(5.32)

We can simplify terms in (5.32). First, H(V ) = h(Pe), the entropy of a binary random variable

with success probability Pe. Furthermore, X is deterministic given V = 0 and Y = y, so H(X|V =

0, Y = y) = 0. Finally, if V = 1 and Y = y, then ˆX is known and X can take up to |X| − 1 values.

Thus H(X|V = 1, Y = y) ≤ log(|X| − 1). Putting these facts together, we arrive at:

H(X|Y )

≤

h(Pe) + log(|X| − 1)P(V = 1)

(5.33)

=

h(Pe) + Pe log(|X| − 1)

(5.34)

A weaker version of Fano’s Inequality uses the facts that h(Pe) ≤ 1 and log(|X| − 1) ≤ log(|X|):

H(X|Y ) ≤ 1 + Pe log(|X|)

(5.35)

or equivalently,

Pe ≥ H(X|Y ) − 1

log(X)

(5.36)

5.8

Converse Theorem

Theorem 47 (Converse Theorem). If R &gt; C(I), then rate R is not achievable.

Proof

log M − H(J|Y n) = H(J) − H(J|Y n)

(5.37)

= I(J; Y n)

(5.38)

= H(Y n) − H(Y n|J)

(5.39)

=

�

i

H(Yi|Y i−1) −

�

i

H(Yi|Y i−1, J)

(5.40)

≤

�

i

H(Yi) −

�

i

H(Yi|Y i−1, J, Xn) (conditioning reduces entropy)

(5.41)

=

�

i

H(Yi) −

�

i

H(Yi|Xi) (memorylessness)

(5.42)

=

�

i

I(Xi; Yi)

(5.43)

≤ nC(I)

(5.44)

Thus, for schemes with rate (= log M

n

) ≥ R, we have

Pe ≥ H(J|Y n) − 1

log M

≥ log M − nC(I) − 1

log M

≥ 1 − C(I)

R

− 1

nR

n→∞

−−−→ 1 − C(I)

R

(5.45)

EE376A COURSE NOTES

41


If R &gt; C(I), then Pe is bounded from below by a positive constant, so it does not approach 0.

Therefore, R &gt; C(I) is not achievable.

5.9

Some Notes on the Direct and Converse Theorems

5.9.1

Communication with Feedback: Xi(J, Y i−1)

Even if the encoder gets feedback of what has been received on the other side of the channel, one

can verify that the proof of converse carries over verbatim; C = C(I) with or without feedback!

But, feedback can help improve simplicity and reliability of schemes to achieve the best rate. Here

is an example:

Example 48. Communicating Through Erasure Channel

Recall that the capacity of the erasure channel (Fig. 7.2) is C = 1 − α bits/channel use. If

feedback exists, the transmitter can repeat each information bit until it goes through unerased.

On average, one needs 1/(1 − α) channel uses per information bit.

This means that the rate

achieved by this scheme is 1 − α bits/channel use. This simple scheme is completely reliable since

the probability of error is equal to zero (every bit will eventually be error-free).

0

1

e

0

1

1-α

1-α

α

α

Figure 5.2: An Erasure Channel

5.9.2

Practical Schemes

In the proof of the direct part, we showed mere existence of Cn (a codebook achieving the rate

equivalent to the channel capacity) with a size |Cn| ≥ 2nR, and small Pe. Even if such Cn is given,

encoding and decoding using this codebook for large n is not practical. For practical schemes, see:

1. LDPC Codes: "Low Density Parity Check Codes", Gallager 1963 Thesis [3].

2. Polar Codes: "Channel Polarization", Arikan 2009 [4].

3. Or, take EE388 – Modern Coding Theory.

5.9.3

Pe vs. Pmax

In our discussion so far, our notion of reliability has been the (average) probability of error, which

is deﬁned as:

EE376A COURSE NOTES

42


Pe = P( ˆJ ̸= J) = 1

M

M

�

j=1

P( ˆJ ̸= J|J = j)

(5.46)

A more stringent notion of reliability is the maximal probability of error Pmax, which is deﬁned as:

Pmax = max

1≤j≤M P( ˆJ ̸= j|J = j)

(5.47)

It turns out that our results, i.e., direct and converse theorems, are still valid for this more stringent

notion of reliability. The converse theorem is clear. If arbitrarily small Pe cannot be achieved,

arbitrarily small Pmax cannot be achieved either, therefore the converse theorem holds for Pmax.

We now show that the result of the direct proof holds for vanishing Pmax. Note that with application

of the Markov inequality, we have:

|{1 ≤ j ≤ M : P( ˆJ ̸= j|J = j) ≤ 2Pe}| ≥ M

2

(5.48)

Given Cn with |Cn| = M and Pe, there exists C′

n with |C′

n| = M/2 and Pmax ≤ 2Pe. By extracting

a better half of Cn, one can construct C′

n. The rate of C′

n is:

Rate of C′

n ≥ log(M/2)

n

= log M

n

− 1

n

(5.49)

This implies that if there exists schemes of rate ≥ R with Pe → 0, then for any ϵ &gt; 0, there exists

schemes of rate ≥ R − ϵ with Pmax → 0

EE376A COURSE NOTES

43


Bibliography

[1] D. J. C. MacKay, Information Theory, Inference, and Learning Algorithms, Cambridge Uni-

versity Press, UK, 2003.

[2] S. Geman and D. Geman, “Stochastic Relaxation, Gibbs Distributions, and the Bayesian

Restoration of Images,” IEEE Trans. on Pattern Analysis and Machine Intelligence, vol. 6,

pp. 721–741, 1984.

[3] R. G. Gallager, Low-Density Parity-Check Codes, Cambridge, MA: MIT Press, 1963.

[4] E. Arikan, “Channel polarization: A method for constructing capacity achieving codes for

symmetric binary-input memoryless channels,” IEEE Trans. Inf. Theory, vol. 55, no. 7, pp.

3051–3073, July 2009.

44


Chapter 6

Method of Types

For additional material on the Method of Types, we refer the reader to [1] (Section 11.1).

6.1

Method of Types

Denote xn = (x1, . . . , xn), with xi ∈ X = {1, 2, . . . , r}.

Deﬁnition 49. The empirical distribution or type of xn is the vector (Pxn(1), Pxn(2), . . . Pxn(r))

of relative frequencies Pxn(a) = N(a|xn)

n

, where N(a|xn) = �n

i=1 1{xi=a}.

Deﬁnition 50. Pn denotes the collection of all empirical distributions of sequences of length n.

Example 51.

X = {0, 1}

Pn =

�

(0, 1) ,

� 1

n, n − 1

n

�

,

� 2

n, n − 2

n

�

, . . . , (1, 0)

�

.

Deﬁnition 52. If P ∈ Pn (probabilities are integer multiples of 1/n), the type class or type of P

is T(P) = {xn : Pxn = P}. The type class of xn is Txn = T (Pxn) = {˜x : P˜xn = Pxn}.

Example 53.

X = {a, b, c}, n = 5, xn = (aacba)

Then Pxn = (3/5, 1/5, 1/5)

Txn = {aaabc, aaacb, . . . , cbaaa}

|Txn| =

�

5

3 1 1

� =

5!

3!1!1! = 20.

45


Theorem 54. |Pn| ≤ (n + 1)r−1

Proof

Type of xn is determined by (N (1|xn) , N (2|xn) , . . . , N (r|xn)). Each component can

assume no more than n + 1 values (0 ≤ N (i|xn) ≤ n) (and the last component is dictated by the

others).

Example 55. For X = {0, 1},

|Pn| = n + 1 = (n + 1)r−1.

Notation:

- Q = {Q(x)}x∈X is a PMF, write H(Q) for H(X) when X ∼ Q.

- Qn(xn) = �n

i=1 Q(xi), S ⊆ X n, Qn(S) = �

xn∈S Qn(xn).

Theorem 56. ∀xn : Qn(xn) = 2−n[H(Pxn)+D(Pxn||Q)].

Proof

Qn(xn) =

n

�

i=1

Q(xi)

= 2

�n

i=1 log Q(xi)

= 2

�

a∈X N(a|xn) log Q(a)

= 2n�

a∈X

N(a|xn)

n

log Q(a)

= 2−n�

a∈X

N(a|xn)

n

log

1

Q(a)

= 2−n��

a∈X Pxn(a) log

1

Q(a)

�

= 2

−n

��

a∈X Pxn(a) log

1

Pxn (a) +�

a∈X Pxn(a) log

Pxn (a)

Q(a)

�

= 2−n[H(Pxn)+D(Pxn||Q)].

Theorem 57. ∀P ∈ Pn,

1

(n + 1)r−1 2nH(P) ≤ |T(P)| ≤ 2nH(P).

Note: |T(P)| =

�

n

nP(1) nP(2) ... nP(r)

� =

n!

�

a∈X (nP(a))!.

EE376A COURSE NOTES

46


Proof

UPPER BOUND:

1 ≥ P n (T(P)) =

�

xn∈T(P)

P n(xn)

= |T(P)|2−n[H(P)+D(P||P)]

= |T(P)|2−nH(P).

For the lower bound we will use a Lemma.

Lemma: ∀P, Q ∈ Pn : P n (T(P)) ≥ P n (T(Q)).

Proof

P n (T(P))

P n (T(Q)) = |T(P)| �

a∈X P(a)[nP(a)]

|T(Q)| �

a∈X P(a)[nQ(a)] =

�

n

nP(1) ... nP(r)

�

�

n

nQ(1) ... nQ(r)

�

�

a∈X

P(a)n[P(a)−Q(a)]

=

�

a∈X

(nQ(a))!

(nP(a))!P(a)n[P(a)−Q(a)]

Note: m!

n! ≥ nm−n

If m &gt; n, then m!

n! = m(m − 1) . . . (n + 1) ≥ nm−n.

If n &gt; m, then m!

n! =

1

n(n − 1) . . . (m + 1) ≥

� 1

n

�n−m

= nm−n.

Therefore,

�

a∈X

(nQ(a))!

(nP(a))!P(a)n[P(a)−Q(a)] ≥

�

a∈X

(nP(a))n[Q(a)−P(a)] P(a)n[P(a)−Q(a)]

=

�

a∈X

nn[P(a)−Q(a)]

= nn�

a∈X [P(a)−Q(a)]

= 1.

Proof

PROOF OF LOWER BOUND:

1 =

�

Q∈Pn

P n (T(Q)) ≤ |Pn| max

Q P n (T(Q))

= |Pn|P n (T(P))

= |Pn||T(P)|2−n[H(P)+D(P||P)]

≤ (n + 1)r−1 |T(P)|2−nH(P).

EE376A COURSE NOTES

47


Theorem 58. ∀P ∈ Pn, Q,

1

(n + 1)r 2−nD(P||Q) ≤ Qn (T(P)) ≤ 2−nD(P||Q).

Proof

Qn (T(P)) = |T(P)|2−n[H(P)+D(P||Q)].

Now bound |T(P)| as in previous theorem.

Note: We will write αn .= βn : “equality to ﬁrst order in the exponent"

⇐⇒ 1

n log αn

βn

n→∞

−−−→ 0

⇐⇒ | 1

n log αn − 1

n log βn| n→∞

−−−→ 0

E.g. : αn .= 2nJ ⇐⇒ αn = 2n(J+ϵn) where ϵn

n→∞

−−−→ 0.

6.1.1

Recap on Types

Consider the sequence xn ∈ X n, where X is a ﬁnite alphabet. Let Pxn be the empirical distribution

and Pn the set of all empirical distributions over sequences of length n. Then we deﬁne the type

to be:

T(P) = {xn : Pxn = P},

for P ∈ Pn. We have shown that:

1. |Pn| ≤ (n + 1)|x|

2. Qn(xn) = 2−n[H(Pxn)+D(Pxn||Q)]

3.

1

(n+1)|x| 2nH(p) ≤ T(P) ≤ 2nH(p), or equivalently, |T(P)| .= 2nH(P),

P ∈ Pn.

4.

1

(n+1)|x| 2−nD(Pxn||Q) ≤ Q(T(P)) ≤ 2−nD(Pxn||Q), or equivalently, Qn (T(P)) .= 2−nD(P||Q).

6.2

A Version of Sanov’s Theorem

Next we prove a version of Sanov’s Theorem, which bounds the probability that a function’s

empirical mean exceeds some value α.

EE376A COURSE NOTES

48


Theorem 59. Sanov’s Theorem. For suﬃciently large n, we have

1

(n + 1)|x| 2−n min D(P||Q) ≤

�

1

n

n

�

i=1

f (Xi)) ≥ α

�

≤ (n + 1)|x|2−n min D(P||Q),

where the min is over the set {P : P ∈ Pn, ⟨Pxn, f⟩ ≥ α}.

Proof

First observe that we can write

1

n

n

�

i=0

f(x) = 1

n

�

a∈X

N(a|xn)f(a)

=

�

a∈X

Pxn(a)f(a)

= ⟨Pxn, f⟩

where we have used the Euclidean inner product, deﬁned as ⟨a, b⟩ := �n

i=1 aibi for a, b ∈ R. Then

by the Law of Large numbers,

1

n

n

�

i=1

f(Xi) ≈ EX∼Qf(X)

=

�

a∈X

Q(a)f(a)

= ⟨Q, f⟩

We can proceed to ﬁnd the desired upper bound.

P

�

1

n

n

�

i=1

f(Xi) ≥ α

�

= P(⟨Pxn, f⟩)

= Qn





�

P∈Pn,⟨Pxn,f⟩≥α

T(P)





=

�

P∈Pn,⟨Pxn,f⟩≥α

Qn(T(P))

≤ |Pn| max Qn(T(P))

≤ (n + 1)|x| max 2−nD(P||Q)

= (n + 1)|x|2−n min D(P||Q)

Now we solve for the lower bound:

P

�

1

n

n

�

i=1

f(Xi) ≥ α

�

≥ max Qn(T(P))

≥ max

1

(n + 1)|x| 2−nD(P||Q)

=

1

(n + 1)|x| 2−n min D(P||Q)

EE376A COURSE NOTES

49


Note that we are taking the min, max over the set {P : P ∈ Pn, ⟨Pxn, f⟩ ≥ α}. Therefore, we

have, up to a polynomial in n, that P

�

1

n

�n

i=1 f(Xi) ≥ α

� .= 2−nD∗(α) where D∗(α) = min D(P||Q).

This is exactly what we were looking for.

Example 60. Take Xi ∼ Ber

�

1

2

�

. Then:

P (fraction of ones in X1X2 · · · Xn ≥ α) = P

�

1

n

n

�

i=1

Xi ≥ α

�

.= 2−nD∗(α)

where D∗(α) = min D(Ber(α)||Ber(1/2)). This gives:

D∗(α) =















0

0 ≤ α ≤ 1

2

D(Ber(α)||Ber(1/2))

1

2 &lt; α ≤ 1

∞

α &gt; 1

and since

D(Ber(p)||Ber(1/2)) = α log α

1/2 + (1 − α) log 1 − α

1/2

= 1 − h(α)

where h(·) is the binary entropy function. Thus we can write

D∗(α) =















0

0 ≤ α ≤ 1

2

1 − h(α)

1

2 &lt; α ≤ 1

∞

α &gt; 1

Interestingly, this function explodes at α = 1, which makes sense because the probability that the

mean of random variables which take values up to 1 is greater than 1 is impossible. Furthermore,

we have a region where the cost of mismatch is zero, since we are guaranteed that one of the

probabilities is always going to be ≥ 1/2, so we would expect our mean to be so as well.

EE376A COURSE NOTES

50


Bibliography

[1] Cover, Thomas M., and Joy A. Thomas. Elements of information theory. John Wiley &amp; Sons,

2012.

51


Chapter 7

Conditional and Joint Typicality

Notation:

We always write a sequence of symbols by small letter. For example xn is an individual sequence

without any probability distribution assigned to it. We use capital letter for random variables, e.g.

Xn i.i.d. according to some distribution. Throughout, X will denote the set of possible values a

symbol can take.

Before going forward, we deﬁne empirical distribution.

Deﬁnition 61. For any sequence xn, empirical distribution is the probability distribution derived

for letters of the alphabet based on frequency of appearance of that speciﬁc letter in the sequence.

More precisely:

pxn(a) = 1

n

�

1(xi = a),

∀a ∈ X

(7.1)

7.1

Typical Set (again)

A rough intuition for typical sets is that if one picks a sequence from an i.i.d distribution, p ∼ Xn,

then the typical set T (X) is a set of length n sequences with the following properties:

1. A sequence chosen at random will be in the typical set with probability almost one.

2. All the elements of the typical set have (almost) equal probabilities.

More precisely, if T (X) is the typical set, |T (X)| ≈ 2nH(X) and probability of each sequence inside

the typical set is ∼ 2−nH(X). So a random sequence chosen from the set looks like one chosen

uniformly from the typical set.

7.2

δ–strongly typical set

Deﬁnition 62. A sequence xn is said to be strongly δ typical with respect to the pmf P if,

∀a ∈ X : |Pxn(a) − P(a)| ≤ δP(a)

Where X is the support of the distribution.

52








Typical(Set(

All(sequences(of(

length(n(

Figure 7.1: Space of all sequences and typical set inside.

Deﬁnition 63. The strongly δ-typical set, Tδ(P), is the set of all strongly δ typical sequences. That

is

Tδ(P) = {xn : |Pxn(a) − P(a)| ≤ δP(a)}

For reference, recall that the weakly ϵ-typical set is:

Aϵ(P) =

�

xn :

����− 1

n log P(xn) − H(P)

���� ≤ ϵ

�

Example 64. Consider the following extreme example where P(a) =

1

|X| is uniform with a ∈ X.

So for all xn,

P(xn) =

1

|X|n

= 2−n log |X|

= 2−nH(p)

Therefore, for all ϵ &gt; 0, A(n)

ϵ

(P) = X n! This makes sense because this is a uniform distribution so

you would always expect the typical sequence to include all possibilities regardless of n.

Note that this "strongly typical" set is diﬀerent from the other "(weakly) typical" set deﬁned

in previous chapters. This new notion is stronger, but as we will see it retains all the desirable

properties of typicality, and more. The following example illustrates diﬀerence of this strong notion

and weak notion deﬁned earlier:

Example 65. Suppose that alphabet is X = {a, b, c} with the probabilities p(a) = 0.1, p(b) = 0.8

and p(c) = 0.1. Now consider two strings of length 1000:

x1000

strong = (100a, 800b, 100c)

x1000

weak = (200a, 800b)

In this example, these two sequences have same probability, so they are both identical in the weak

notion of typical set A(ϵ)

1000 (for some ϵ). But it is not hard to see that x1000

strong is a δ- strong typical

EE376A COURSE NOTES

53


set while the other is not (for suﬃciently small δ). The strong notion is sensitive to frequency of

diﬀerent letters and not only the total probability of sequence.

We will show in the homework that that we preserve important properties of typical sets in the

new strong notion. Speciﬁcally, we will show the following results:

1. ∀ δ &gt; 0, there exists ϵ = δH(p) such that Tδ(P) ⊆ Aϵ(P) (i.e., strong typical sets are inside

weak typical sets).

2. Empirical probability pXn is almost equal to the probability distribution p. Therefore p(xn) ≈

2−nH(X) for xn in the strong typical set.

3. There exists ϵ(δ) such that for all n suﬃciently large:

2n[H(P)−ϵ(δ)] ≤ |Tϵ(P)| ≤ 2n[H(P)+ϵ(δ)],

where ϵ(δ) → 0 as δ → 0. Thus |Tδ(X)| ≈ 2nH.

4. P(xn ∈ Tδ(X)) → 1 as n → ∞

7.3

δ–jointly typical set

In this section we extend the notion of δ - typical sets to pair of sequences xn = (x1, ..., xn) and

yn = (y1, ..., yn) from alphabets X and Y.

Deﬁnition 66. For xn = (x1, x2, . . . xn) ∈ X n and yn = (y1, y2, . . . yn) ∈ Yn, the joint empirical

distribution is deﬁned as

Pxn,yn(x, y) = 1

n |{i ∈ {1, . . . , n} : xi = x, yi = y}|

= 1

nN (x, y | xn, yn)

where we have deﬁned N (x, y | xn, yn) := |{i ∈ {1, . . . , } : xi = x, yi = y}|

Deﬁnition 67. A pair of sequences (xn, yn) is said to be δ - jointly typical with respect to a pmf

PXY on X × Y if:

|Pxn,yn(x, y) − P(x, y)| ≤ δP(x, y),

where Pxn,yn(x, y) is the empirical distribution.

Then, we can make the following deﬁnition.

Deﬁnition 68. For (X, Y ) ∼ P, the jointly δ typical set is given by

Tδ(P) = {(Xn, Y n) : |Pxn,yn(x, y) − P(x, y)| &lt; δP(x, y), ∀(x, y) ∈ X × Y}

If we look carefully, nothing is really very new. We just require that empirical distribution of

pair of sequences be δ - close to the pmf PXY .

EE376A COURSE NOTES

54


Often as is the case with H(X) vs H(P), we will write Tδ(X) for Tδ(P) when P ∼ X and

Tδ(X, Y ) for Tδ(P) when P ∼ (X, Y ).

The notion of strong vs weak typicality is important. For example, consider the random variable

Gn = 1

n

�n

i=1 g(xi). If Xn is strongly typical, then Gn is close to E [g(x)] for large n. On the other

hand, this would not necessarily have been the case if Xn were only weakly typical.

It is easy to see that size of typical set is:

|Tδ(X, Y )| ≈ 2nH(X,Y )

and

P((xn, yn) ∈ Tδ(X, Y )) ≈ 2−nH(X,Y )

In Figure 7.2 we have depicted the sequences of length n from alphabet X on the x axis and

sequences from alphabet Y on the y axis.

• Conditional Typicality Lemma: Let xn 2 T (n)

✏0

(X) and Y n ⇠ Qn

i=1 pY |X(yi|xi).

Then for every ✏ &gt; ✏0,

P{(xn, Y n) 2 T (n)

✏

(X, Y )} ! 1 as n ! 1

This follows by the LLN. Note that the condition ✏ &gt; ✏0 is crucial to apply the

LLN (why?)

The conditional typicality lemma implies that for all xn 2 T (n)

✏0

(X)

|T (n)

✏

(Y |xn)| � (1 � ✏)2n(H(Y |X)��(✏)) for n su�ciently large

• In fact, a stronger statement holds: For every xn 2 T (n)

✏

(X) and n su�ciently

large,

|T (n)

✏

(Y |xn)| � 2n(H(Y |X)��0(✏)),

for some �0(✏) ! 0 as ✏ ! 0

This can be proved by counting jointly typical yn sequences (the method of

types [12]) as shown in the Appendix

LNIT: Information Measures and Typical Sequences (2010-06-22 08:45)

Page 2 – 19

Useful Picture

xn

yn

T (n)

✏

(Y )

⇣

| · | .= 2nH(Y )⌘

T (n)

✏

(X)

⇣

| · | .= 2nH(X)⌘

T (n)

✏

(X, Y )

⇣

| · | .= 2nH(X,Y )⌘

T (n)

✏

(Y |xn)

⇣

| · | .= 2nH(Y |X)⌘

T (n)

✏

(X|yn)

⇣

| · | .= 2nH(X|Y )⌘

LNIT: Information Measures and Typical Sequences (2010-06-22 08:45)

Page 2 – 20

Figure 7.2: A useful diagram depicting typical sets, from El Gamal and Kim (Chapter 2)

Then we can look inside the table and any point corresponds to a pair of sequences. We have

marked the jointly typical sets with dots. It is easy to see that if a set is jointly typical then both

of the sequences in the set are typical as well. Also we will see in the next section that number

of dots in the column corresponding to a typical xn sequence is approximately 2nH(Y |X) (a similar

statement is also correct for rows). We can quickly check that this is consistent by a counting

argument: we know that number of typical xn sequences is 2nH(X) and each column there are

2nH(Y |X) jointly typical pairs. So in total there are 2nH(X) · 2nH(Y |X) number of typical pairs. But

2nH(X) · 2nH(Y |X) = 2n(H(X)+H(Y |X)) = 2nH(X,Y ) which is consistent to the fact that total number

of jointly typical pairs is equal to 2nH(X,Y ).

EE376A COURSE NOTES

55


7.4

δ–conditional typicality

In many applications of typicality, we know one sequence (say, the input to a channel) and want to

know typical values for some other sequence. In this case, a useful concept is conditional typicality.

Deﬁnition 69. Fix δ &gt; 0, xn ∈ X n. Then, the conditional typical set Tδ(Y |xn) is deﬁned by

Tδ(Y |xn) ≜ {yn ∈ Yn : (xn, yn) ∈ Tδ(X, Y )}.

As usual, it is useful to have bounds on the size of this set. For all δ′ &lt; δ (and n large enough,

as usual), xn ∈ Tδ′(X) ⇒ |Tδ(Y |xn)| .= 2nH(Y |X) (below, we will be a bit more careful, and we

will see that this exponent should depend on a function ϵ(δ) which vanishes as δ → 0). Note that

this asymptotic behavior is does not depend on the speciﬁc sequence xn, as long as xn is typical!

This is all in accordance with the intuition we have developed: all typical sequences behave roughly

similarly. If xn ̸∈ Tδ(X), then |Tδ(Y |xn)| = 0, as (xn, yn) cannot be jointly typical if xn is not

typical.

To illustrate the methods used to describe the asymptotic behavior of |Tδ(Y |xn)|, we ﬁnd an

upper bound on this value. If xn ∈ Tδ′(X) ⊆ Tδ(X) and yn ∈ Tδ(Y |xn), then by deﬁnition of the

conditional typical set, (xn, yn) ∈ Tδ(X, Y ). Since strong typicality implies weak typicality,

(1 − δ)H(X, Y ) ≤ − 1

n log p(xn, yn) ≤ (1 + δ)H(X, Y ),

(7.2)

(1 − δ)H(X) ≤ − 1

n log p(xn) ≤ (1 + δ)H(X).

(7.3)

So, ﬁx some xn ∈ Tδ′(X). Then,

1 ≥

�

yn∈Tδ(Y |xn)

p(yn|xn) =

�

yn∈Tδ(Y |xn)

p(xn, yn)

p(xn)

≥ |Tδ(Y |xn)| · 2−n(H(X,Y )−H(X)+ϵ(δ)) = |Tδ(Y |xn)| · 2−n(H(Y |X)+ϵ(δ))

⇒ |Tδ(Y |xn)| ≤ 2n(H(Y |X)+ϵ(δ)).

7.5

Encoding – Decoding Schemes for Sending Messages

We now explain the idea of how these concepts relate to sending messages over channels. Consider

a discrete memoryless channel (DMC), described by conditional probability distribution p(y|x),

where x is the input to the channel and y is the output. Then,

p(yn|xn) =

n

�

i=1

p(yi|xi).

Say we want to send one of M messages over a channel. We encode each m ∈ {1, . . . , M} into a

codeword Xn(m). We then send the codeword over the channel, obtaining Y n. Finally, we use a

decoding rule ˆ

M(Y n) which yields ˆ

M = m with high probability.

The conditional typicality lemma (proved in the homework) characterizes the behavior of this

channel for large n: if we choose a typical input, then the output is essentially chosen uniformly at

random from Tδ(Y |xn). More precisely, for all δ′ &lt; δ, xn ∈ Tδ′(X) implies that

P(yn ∈ Tδ(Y |xn)) = P((xn, Y n) ∈ Tδ(X, Y )) → 1,

EE376A COURSE NOTES

56


as n → ∞; furthermore, the probability of obtaining each element of Tδ(Y |xn) is essentially

1

|Tδ(Y |xn)| ≈ 2−nH(Y |X).

This lemma limits the values of M for which there is an encoding – decoding scheme that can

succeed with high probability. As illustrated in Figure 7.3, what we are doing is choosing a typical

codeword xn ∈ Tδ(X), and receiving some element Y n ∈ Tδ(Y |xn). We can think of this latter set

as a “noise ball": it is the set of outputs yn that we could typically expect to receive, given that

our input is xn. If these noise balls corresponding to diﬀerent inputs overlap signiﬁcantly, then we

have no hope for being able to obtain m from Y n with high probability, as multiple inputs give

indistinguishable outputs. Since, for any input, the output will (with high probability) be typical

– that is, Y n ∈ Tδ(Y ), the number of messages we can send is limited by the number of noise balls

we can ﬁt inside of Tδ(Y ). Since the number of elements of Tδ(Y ) is (approximately) 2nH(Y ) and

the number of elements of Tδ(Y |xn) is (approximately) 2nH(Y |X), it follows that the number of

messages we can send over this channel is at most

2nH(Y )

2nH(Y |X) = 2n(H(Y )−H(Y |X)) = 2nI(X;Y ) ≤ 2nC,

where C is the channel capacity. Note that this argument does not give a construction that lets

us attain this upper bound on the communication rate. The magic of the direct part of Shannon’s

channel coding theorem is that random coding lets us attain this upper bound.





Typical(Set(

All(sequences(of(

length(n(





Typical(Set(

All(sequences(of(

length(n(













xn(1)(

xn(2)(

Tδ(Y|xn(2))(

Tδ(Y|xn(1))(

Figure 7.3: The typical sets Tδ(X), Tδ(Y ), and Tδ(Y |xn).

EE376A COURSE NOTES

57


7.6

Joint Typicality Lemma

In this ﬁnal section, we discuss the joint typicality lemma, which tells us how well we can guess the

output without knowing the input. Intuitively, if X and Y are strongly correlated, then we might

expect that not knowing the input could strongly impair our ability to guess the output, and if X

and Y are independent then not knowing the input should not at all impair our ability to guess

the output. So, say that the actual input is xn. We will look for a bound on the probability that

an output will be in the conditional typical set Tδ(Y |xn) – that is, the probability that we’ll guess

that xn was the input – in terms of the mutual information I(X; Y ).

Fix any δ &gt; 0 and δ′ &lt; δ, and ﬁx xn ∈ Tδ′(X). Choose ˜Y n ∈ Yn by choosing each ˜Yi i.i.d.

according to the marginal distribution p(y) (so, intuitively we’ve forgotten what we sent as input

to the channel, and are simulating the output). Then, noting that

yn ∈ Tδ(Y |xn) ⇒ yn ∈ Tδ(Y ) ⇒ p(yn) ≤ 2−n(H(Y )−ϵ(δ)),

where ϵ(δ) is a function that approaches 0 as δ → 0, we have

P( ˜Y n ∈ Tδ(Y |xn)) = P((xn, ˜Y n) ∈ Tδ(X, Y ))

=

�

yn∈Tδ(Y |xn)

p(yn)

≤ |Tδ(Y |xn)| · 2−n(H(Y )−ϵ(δ))

≤ 2nH(Y |X)+ϵ(δ) · 2−n(H(Y )−ϵ(δ))

= 2−n(H(Y )−H(Y |X)−˜ϵ(δ))

= 2−n(I(X;Y )−˜ϵ(δ)),

where ˜ϵ(δ) → 0 as δ → 0.

Intuitive argument for joint typicality lemma The joint typicality lemma asserts that

the probability of observing two random xn and yn sequences is roughly 2−nI(X;Y ). Observe that

there are roughly 2nH(X) typical xn sequences, and 2nH(Y ) typical yn sequences. The total number

of jointly typical sequences is 2nH(X,Y ). Thus, what is the probability that two randomly chosen

sequences are jointly typical?

≈

2nH(X,Y )

2nH(X) × 2nH(Y ) = 2−nI(X;Y )

(7.4)

EE376A COURSE NOTES

58


Chapter 8

Lossy Compression &amp; Rate Distortion

Theory

8.1

Deﬁnitions and main result

Encoder

Decoder

UN = U1, . . . , UN

J ∈ {1, 2, . . . , M}

VN = V1, . . . , VN

where Ui ∼ U, i.i.d.

A scheme is characterized by:

• N, M

• An encoder, i.e., a mapping from UN to J ∈ {1, 2, ..., M} (log M bits used to encode a symbol

sequence, where a symbol sequence is UN and a symbol is Ui)

• A decoder, i.e., a mapping from J ∈ {1, 2, ..., M} to VN

In working with lossy compression, we examine two things:

1. Rate R = log(M)

N

bits

source symbol

2. Expected distortion (ﬁgure of merit) = d(UN, V N) = E[ 1

N

N

�

i=1

d(Ui, Vi)] (we always specify

distortion on a per-symbol basis, and then average the distortions to arrive at d(UN, V N))

There’s a trade-oﬀ between rate and distortion

symbol . Distortion theory deals with this trade-oﬀ.

Deﬁnition 70. (R,D) is achievable if ∀ϵ &gt; 0 ∃ scheme (N,M,encoder,decoder) such that log M

N

≤

R + ϵ and E[d(UN, V N)] ≤ D + ϵ

Deﬁnition 71. R(D) ≜ inf{R′ : (R′, D) is achievable}

Deﬁnition 72. R(D)(I) ≜

min

E[d(U,V )]≤DI(U; V )

59


Theorem 73. R(D) = R(I)(D).

Proof

⇔

�

Direct Part : R(D) ≤ R(I)D

Converse Part : R(D) ≥ R(I)D

The proof of the direct part and the converse part are given below.

Note that R(D) is something we can’t solve for (solution space is too large!), but R(I)(D) is

something we can solve for (solution space is reasonable).

Theorem 74. R(D) is convex, i.e.,

∀0 &lt; α &lt; 1 , D0 , D1 : R(αD0 + (1 − α)D1) ≤ αR(D0) + (1 − α)R(D1)

Sketch of proof: We consider a “time-sharing” scheme for encoding N bits. We encode the

ﬁrst αN bits using a “good" scheme for distortion D = D0 and encode the last (1 − α)N bits

using a “good” scheme for D = D1. Overall, the number of bits in the compressed message is

NαR(D0) + N(1 − α)R(D1), so that the rate is αR(D0) + (1 − α)R(D1). Further, the expected

distortion is the average, weighted by α between the distortions between the two diﬀerent schemes,

i.e. αD0 + (1 − α)D1. We therefore have constructed a scheme which achieves distortion αD0 +

(1 − α)D1 with rate αR(D0) + (1 − α)R(D1), and the optimal scheme can only do better. That is

R(αD0 + (1 − α)D1) ≤ αR(D0) + (1 − α)R(D1),

as desired.

8.2

Examples

Example 75.

Consider U ∼ Ber(p), p ≤ 1

2 and Hamming distortion. That is

d(u, v) =

�

0

for u = v

1

for u ̸= v

Claim:

R(D) =

�

h2(p) − h2(D)

0 ≤ p ≤ D

0

D &gt; p

Proof: We will not be overly pedantic by worrying about small ϵ factors in the proof.

Note we can achieve distortion p without sending any information by setting V = 0. Therefore,

for D &gt; p, R(D) = 0, as claimed. For the remainder of the proof, therefore, we assume D ≤ p ≤ 1

2.

EE376A COURSE NOTES

60


Consider U, V such that U ∼ Ber(p) and Ed(U, V ) = P(U ̸= V ) ≤ D. We can show that R(D)

is lower-bounded by h2(p) − h2(D) by noting

I(U; V ) = H(U) − H(U|V )

= H(U) − H(U ⊖2 V |V )

≥ H(U) − H(U ⊖2 V )

= h2(p) − h2(P(U ̸= V ))

≥ h2(p) − h2(D)

In the second line we have used the fact that H(U|V ) = H(U ⊖2 V |V ) because there is a one to one

mapping (U, V ) ↔ (U ⊖2 V, V ). In the third line, we have used that conditioning reduces entropy,

so H(U ⊖2 V |V ) ≤ H(U ⊖2 V ). Finally, in the last line we have used that h2 is increasing on [0, 1

2]

and that P(U ̸= V ) ≤ D ≤ p ≤ 1

2. This establishes that R(D) ≥ h2(p) − h2(D).

Now we must show equality can be achieved. The ﬁrst and second inequalities above demon-

strate that we get equality if and only if

1. U ⊖2 V is independent of V .

2. U ⊖2 V ∼ Ber(D).

V ∼ Ber(q)

+

Z ∼ Ber(D)

U ∼ Ber(p)

Denoting U ⊖2 V ≜ Z, this is equivalent to ﬁnding q such that if V ∼ Ber(q) and Z ∼ Ber(D)

is independent of V , U = V ⊕2 Z ∼ Ber(p). Because V ⊕2 Z is binary, it is Bernoulli, with

p = P(U = 1)

= P(V = 1)P(Z = 0) + P(V = 0)P(Z = 1)

= q(1 − D) + (1 − q)D

Solving for q gives

q = p − D

1 − 2D

Because D ≤ p ≤ 1

2, both the numerator and denominator are positive. Further, because p ≤ 1

2,

we have q ≤ 1/2−D

1−2D = 1

2, which shows that q is a valid probability. This completes the proof.

Example 76. Consider U ∼ N(0, σ2) and distortion given by: d(u, v) = (U − V )2

Claim:

R(D) =

�1

2 log((σ2)/D)

0 ≤ D ≤ p

0

D &gt; σ2

EE376A COURSE NOTES

61


Proof: First note we may achieve distortion σ2 without transmitting any information by setting

V = 0 with certainty. Therefore, R(D) = 0 for D &gt; σ2. For the remainder of the proof, therefore,

we assume that D ≤ σ2.

For any U,V such that U ∼ N(0, σ2) and E(U − V )2 ≤ D, we assume D ≤ σ2.

We can ﬁnd the lower-bound by noting

I(U; V ) = h(U) − h(U|V )

= h(U) − h(U − V |V )

≥ h(U) − h(U − V )

≥ h(U) − h(N(0, D))

= 1

2 log 2πEσ2 − 1

2 log 2πeD

= 1

2 log σ2

D

For the ﬁrst inequality we have used that conditioning reduces even the diﬀerential entropy, and

in the second inequality we have used the result, proved earlier in the course that the maximum

diﬀerential entropy of a distribution constrained by Var(U − V ) ≤ D is achieved when U − V ∼

N(0, D). This establishes that R(D) ≥ 1

2 log σ2

D .

Now we must show that equality can be achieved.

The ﬁrst and second inequalities above

demonstrate that we get equality if and only if

1. U − V is independent of V .

2. U − V ∼ N(0, D).

V

+

Z ∼ N(0, D)

U ∼ N(0, σ2)

Denoting U − V ≜ Z, we want to ﬁnd a distribution for V such that Z independent of Z and

distributed N(0, D) makes V + Z ∼ N(0, σ2). We see that this is possible for V ∼ N(0, σ2 − D),

which is a valid distribution because D ≤ σ2. This completes the proof, and R(D) = 1

2 log σ2

D .

8.3

Proof of Direct Part R(D) ≤ R(I)(D)

8.3.1

An Equivalent Statement

First, we are going to show the equivalence of the following statements

R(D) ≤ R(I)(D) ⇐⇒ R(D) ≤ min {I(U; V ) : U, V s.t. E d(U, V ) ≤ D}

⇐⇒ If U, V s.t. E d(U, V ) ≤ D, then R(D) ≤ I(U; V )

⇐⇒ If U, V s.t. E d(U, V ) ≤ D, then (R, D) is achievable for any R &gt; I(U; V ).

EE376A COURSE NOTES

62


Proof

The ﬁrst and second lines follow the deﬁnition of R(I)(D). For the last line, it only suﬃces

to show

R(D) ≤ I(U; V ) ⇐⇒ (R, D) is achievable for any R &gt; I(U; V ).

• For the ⇒ part, consider any R &gt; I(U; V ),

R &gt; I(U; V ) ≥ R(D) = inf{R′ : (R′, D) is achievable}

thus (R, D) is achievable.

• For the ⇐ part, consider some R′′ = I(U; V ) + ϵ. By the assumption (R, D) is achievable for

any R &gt; I(U; V ), implying that (R′′, D) is achievable, and thereafter

R(D) = inf{R′ : (R′, D) is achievable} ≤ R′′ = I(U; V ) + ϵ.

Since ϵ can be arbitrarily small, we must have R(D) ≤ I(U; V ).

Hence we can prove the equivalent statement instead of R(D) ≤ R(I)(D). That’s to show

(R, D) is the achievable for ﬁxed U, V s.t. E[d(U, V )] ≤ D and ﬁxed R &gt; I(U; V ).

8.3.2

Two Useful Lemmas

The proof of the equivalent statement uses two lemmas appearing in the homeworks.Let’s recall

them in advance.

Lemma 77. (Joint Typicality Lemma) Suppose un ∈ Tδ′(U), 0 &lt; δ′ &lt; δ and Vi’s i.i.d.

∼ V ,

2−n(I(U;V )+ϵ(δ)) ≤ P ((un, V n) ∈ Tδ(U, V ))

for suﬃciently large n and some ϵ(δ) &gt; 0 where limδ→0 ϵ(δ) = 0.

Lemma 78. (Typical Average Lemma)

(un, vn) ∈ Tδ(U, V ) =⇒ d(un, vn) ≜ 1

n

n

�

i=1

d(ui, vi) ≤ (1 + δ) E d(U, V )

8.3.3

Proof of the Equivalent Statement

For ﬁxed U, V s.t. E d(U, V ) ≤ D and R &gt; I(U; V ), we are going to show (R, D) is achievable.

Proof

Take M = ⌊2nR⌋. Denote by Cn = {V n(1), V n(2), ..., V n(M)} the random codebook

which is generated by Vi’s i.i.d.

∼ V and independent of U. Let d(un, Cn) = minV n∈Cn d(un, V n).

EE376A COURSE NOTES

63


For suﬃcient small 0 &lt; δ′ &lt; δ which appear in Lemma 77, the assumption R &gt; I(U, V ) implies

R &gt; I(U; V ) + ϵ(δ). For any un ∈ Tδ′(U) and suﬃciently large n,

P (d(un, Cn) &gt; D(1 + δ)) = P (d(un, Vn(i)) &gt; D(1 + δ) for i = 1, 2, ..., M)

(Deﬁnition of d(un, Cn))

= P (d(un, Vn(1)) &gt; D(1 + δ))M

(Vi

i.i.d.

∼ V )

≤ P (d(un, Vn(1)) &gt; E d(U, V )(1 + δ))M (Assumption of E d(U, V ) ≤ D)

≤ P ((un, Vn(1)) ̸∈ Tδ(U, V ))M

(Inverse-negative of Lemma 78)

= [1 − P ((un, Vn(1)) ∈ Tδ(U, V ))]M

≤

�

1 − 2−n(I(U;V )+ϵ(δ))�M

(Lemma 77 with un ∈ Tδ′(U) and large n)

≤ exp

�

−M · 2−n(I(U;V )+ϵ(δ))�

(1 − x ≤ e−x)

So far, we have an upper bound of P (d(un, Cn) &gt; D(1 + δ)) for any un ∈ Tδ′(U) and suﬃciently

large n.

P (d(un, Cn) &gt; D(1 + δ)) ≤ exp

�

−M · 2−n(I(U;V )+ϵ(δ))�

(8.1)

Then for Ui

i.i.d.

∼ U,

P (d(Un, Cn) &gt; D(1 + δ)) =

�

un∈Tδ′(U)

P (d(un, Cn) &gt; D(1 + δ), Un = un)

+

�

un̸∈Tδ′(U)

P (d(un, Cn) &gt; D(1 + δ), Un = un)

≤

�

un∈Tδ′(U)

P (d(un, Cn) &gt; D(1 + δ)) P (Un = un)

(Un independent of Cn)

+ P (Un ̸∈ Tδ′(U))

≤ exp

�

−M · 2−n(I(U;V )+ϵ(δ))�

+ P (Un ̸∈ Tδ′(U))

(Upper bound in Eq. 8.1)

where the ﬁrst term goes to 0 as n → ∞ because

M = ⌊2nR⌋,

R &gt; I(U; V ) + ϵ(δ),

and the second term goes to 0 as n → ∞ because of AEP. Thus for Ui

i.i.d.

∼ U,

P (d(Un, Cn) &gt; D(1 + δ)) → 0 as n → ∞

(8.2)

Further, let d(Cn) = E (d(Un, Cn)|Cn) be the average distortion by random codebook Cn, and thus

d(cn) = E (d(Un, cn)|Cn = cn) = E (d(Un, cn)) (Cn is independent of Un) is the average distortion

EE376A COURSE NOTES

64


by a realization cn of Cn.

E d(Cn) = E [E (d(Un, Cn)|Cn)]

= E (d(Un, Cn))

(tower property)

≤ P (d(Un, Cn) &gt; D(1 + δ)) Dmax

(Dmax ≜ maxu∈U,v∈V d(u, v))

+ P (d(Un, Cn) ≤ D(1 + δ)) D(1 + δ)

→ D(1 + δ) as n → ∞

(Limiting result in Eq. 8.2)

It implies that

E d(Cn) &lt; D + 2δDmax for suﬃciently large n,

which further implies existence of cn, a realization of Cn, satisfying

d(cn) ≤ E d(Cn) &lt; D + 2δDmax for suﬃciently large n.

Taking arbitrarily small δ and suﬃciently large n, we can get the average distortion d(cn) arbitrarily

close to D. And the size of codeword lists

|cn| = M = ⌊2nR⌋ ≤ 2nR.

(R, D) is achieved by the codebook cn.

8.4

Proof of the converse

Proof

Fix a scheme satisfying E[d(UN, V N)] ≤ D, then H(V N) ≤ log M for V N taking M diﬀerent

EE376A COURSE NOTES

65


values.

log M ≥ H(V N)

≥ H(V N) − H(V N | UN)

= I(UN; V N)

= H(UN) − H(UN | V N)

=

N

�

i=1

H(Ui) − H(Ui | Ui−1, V N) (by chain rule)

≥

N

�

i=1

H(Ui) − H(Ui | Ui−1, Vi) (conditioning reduces entropy)

=

N

�

i=1

I(Ui; Vi)

≥

N

�

i=1

R(I)(E[d(Ui, Vi)]) (by deﬁnition ofR(I)(D))

= N

N

�

i=1

1

N R(I)(E[d(Ui, Vi)]) (average ofR(I)(D)over all i)

≥ NR(I)( 1

N

N

�

i=1

E[d(Ui, Vi)]) (By the convexity of R(I)(D))

≥ NR(I)(D) (R(I)(D) is nonincreasing)

rate = log M

N

≥ R(I)(D)

8.5

Geometric Interpretation

I(U; V ) is the expected distortion if both U, V are in jointly typical set, as we just proved. The

following ﬁgures will give a geometric interpretation to the results.

How large does a codebook has to be so that every source sequence in the typical set has a

reconstruction, which it is jointly typical? Let T(U | V N(i)) be the set of source sequences jointly

typical with the reconstruction sequence V N(i). Therefore, to cover every source sequence, we need

a codebook of at least the size of typical set of the input divided by the number of source sequences

one reconstruction can cover.

The size of the codebook =

|T(U)|

|T(U | V N(i))| ≈

2NH(U)

2NH(U|V ) = 2NI(U;V ). This is showed in Fig. 8.1 on

the distortion function.

EE376A COURSE NOTES

66




Figure 8.1: Distortion Function

Achievability: generate V N(i) i.i.d. ∼ V, P((UN, V N(i)) ∈ T(U, V )) ≈ 2−nI(U;V ). Therefore, in

order for all typical sequences to be described, P((UN, V N(i)) ∈ T(U, V ), i = 1, 2, · · · , M) ≈ 1 if

the codebook is suﬃciently large, i.e., if R &gt; I(U; V ), as the codebook is of size ⌊2NR⌋



Figure 8.2: Communication Channel

The communication problem has a similar setup. In order to achieve reliable communication,

the number of messages ≤

|T(Y )|

|T(Y | Xn(i))| =

2nH(Y )

2nH(Y |X) = 2−nI(X;Y ). This communication channel

is shown in Fig. 8.2, as the distortion occurs on VN.

Achievability: ∀i s.t.

P(Y n ∈ T(Y n | Xn(i)|i ̸= j) ≈ 2−nI(X;Y ).

Therefore, because the

number of messages is ⌊2NR⌋, in order to guarantee that P(Y n ∈ T(Y n | Xn(i))for any i ̸= j) ≈ 0,

R &lt; I(X; Y ).

EE376A COURSE NOTES

67


Chapter 9

Joint Source Channel Coding

9.1

Joint Source Channel Coding

Now that we understand lossy compression as well as the communication problem, we can combine

them into a joint source-channel coding theorem. A schematic of this setup is shown below:

Transmitter

Memoryless Channel

PY |X

Receiver

Ui iid ∼ U

UN = (U1, . . . , UN)

Xn

Y n

V N = (V1, . . . , VN)

With this channel description, the goal is to communicate the UN = (U1, U2, . . . , UN) through

the memoryless channel given by PY |X with small expected distortion, measured by E

�

d(UN, V N)

�

.

In other words, the goal is to ﬁnd the best possible distortion given some rate and some noise during

transmission. Note that the Ui are not necessarily bits.

The rate of communication is then

rate = N

n

source symbols

channel use

We also allow an expected distortion E

�

d(UN, V N)

�

, with

d(UN, V N) = 1

N

N

�

i=1

d (Ui, Vi) .

Deﬁnition 79. A rate-distortion pair (ρ, D) is achievable if ∀ϵ &gt; 0, ∃ a scheme with N

n ≥ ρ − ϵ

and E[d(UN, V N)] ≤ D + ϵ.

68


Note: under any scheme, E[d(UN, V N)] ≤ D, and UN → Xn → Y n → V N forms a Markov

chain. Therefore,

nC ≥ I(Xn; Y n) (proven in channel coding converse theorem)

I(Xn; Y n) ≥ I(UN; V N)) (Data processing inequality)

I(UN; V N) ≥ NR(D) (proven in converse of rate distortion theorem)

NR(D)

n

= Rate · R(D) ≤ C.

Thus, if (ρ, D) is achievable ⇒ ρR(D) ≤ C.

Consider the following “Separation Scheme"

UN

−−→

Good Distortion Compressor

N·R(D) bits

−−−−−−−→

Reliable Channel Encoder

Xn

−−→ Memoryless Channel

Y N

−−→

Reliable Channel Decoder

N·R(D) bits

−−−−−−−→

Good Distortion Compressor

V N

−−→

All these pieces work correctly to ensure that distortion and channel noise are handled properly.

It is guaranteed that E[d(UN, V N)] ≈ D provided that n · C ≥ NR(D) · C ≥ N

n · R(D) =

rate · R(D). Thus, if R(D) ≤ C, then (ρ, D) is achievable.

9.2

Source – Channel Separation Theorem

Theorem 80. (ρ, D) is achievable if and only if ρ · R(D) ≤ C.

Essentially, we have separated the problem of compression from the problem of transmission

and have proven that a separated solution is optimal. There is no need nor advantage to address

both problems simultaneously.

D

ρ

Dmax

D0

C

R(D0)

achievable

not achievable

C

R(D)

We can achieve points on the curve above by ﬁrst thinking about representing the data as bits in

an eﬃcient manner (compression) with rate R(D) and then transmitting these bits losslessly across

the channel with rate C. Note that the distortion without sending anything over the channel is

Dmax.

EE376A COURSE NOTES

69


9.3

Examples

Example 81. Binary Source and Binary Channel

Source: U ∼ Ber(p),

0 ≤ p ≤ 1/2

Channel: BSC(q),

0 ≤ q ≤ 1/2

Distortion: Hamming

Recall that for U ∼ Ber(p), the rate distortion function is R(D) = h2(p) − h2(D) and that a

binary symmetric channel with crossover probability q has capacity C = 1 − h2(q)

So, we see that if we want distortion ≤ D, then (for D ≤ p) the maximum achievable rate is:

ρ =

1 − h2(q)

h2(p) − h2(D)

D

ρ

p

achievable

not achievable

1−h2(q)

h2(p)−h2(D)

1−h2(q)

h2(p)

Note that the communication problem corresponds to D = 0.

In particular, if p = 1/2, then if we want distortion ≤ D, the maximum rate we can transmit

at is:

ρ = 1 − h2(q)

1 − h2(D)

D

ρ

1

2

achievable

not achievable

1−h2(q)

1−h2(D)

1 − h2(q)

D = q

1

Consider the following scheme for rate=1:

Channel input: Xi = Ui

reconstruction: Vi = Yi

EE376A COURSE NOTES

70


The expected distortion is then P(Ui ̸= Vi) = P(Xi ̸= Yi) = q

−→ this scheme is optimal, since ρ = (1 − h2(q))/(1 − h2(D = q)) = 1.

In this particular case, it is possible to achieve the optimal rate using a scheme that individually

encodes and transmits each symbol.

Example 82. Gaussian Source and Gaussian Channel

Source: U ∼ N(1, σ2)

Channel: AWGN (Additive White Gaussian Noise Channel) with power constraint P

X

+

Z ∼ (0, 1)

Y

distortion: squared error

Recall that for U ∼ N(1, σ2), the rate distortion function is R(D) = 1

2 log(σ2

D ) (for 0 ≤ D ≤ σ2)

and that the AWGN channel with power constraint P has capacity C = 1

2 log(1 + P)

D

ρ

σ2

achievable

not achievable

log(1+P)

log(σ2/D)

σ2

P+1

1

Then, for a given distortion D ≤ σ2, the maximum achievable rate is

ρ = log(1 + P)

log(σ2/D)

Consider the following scheme at rate=1:

transmit: Xi =

�

P

σ2 Ui

receive: Yi = Xi + Zi =

�

P

σ2 Ui + Zi

reconstruction: Vi = E[Ui|Vi]

The distortion is squared error, so we know that reconstruction using the expected value is

optimal. Thus, we take Vi = E[Ui|Vi].

The expected distortion is then:

EE376A COURSE NOTES

71


E[Ui|Vi] = Var(Ui|Vi)

= Var



Ui

������

�

σ2

P Yi





= Var



Ui

������

Ui +

�

σ2

P Zi





(a)

= σ2(σ2/P)

σ2 + σ2/P

=

σ2

P + 1

where (a) follows from the fact that for X ∼ N(0, σ2

1) independent from Y ∼ N(0, σ2

2):

Var(X|X + Y ) =

σ2

1σ2

2

σ2

1 + σ2

2

Now, at rate = 1:

The optimal D satisﬁes

log(1 + P)

log(σ2/D) = 1

→ 1 + P = σ2

D

So, in the speciﬁc case of rate = 1 we see that the simple scheme above is optimal, just as the

simple scheme for the Binary Source and Channel was also optimal when rate = 1.

EE376A COURSE NOTES

72

