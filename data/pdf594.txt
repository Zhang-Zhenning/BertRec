


Natural Language Processing

with Deep Learning

CS224N/Ling284

Christopher Manning / John Hewitt

Lecture 1: Introduction and Word Vectors


Lecture Plan

Lecture 1: Introduction and Word Vectors

1. The course (10 mins)

2. Human language and word meaning (15 mins)

3. Word2vec introduction (15 mins)

4. Word2vec objective function gradients (25 mins)

5. Optimization basics (5 mins)

6. Looking at word vectors (10 mins or less)

Key learning today: The (astounding!) result that word meaning can be represented rather 

well by a (high-dimensional) vector of real numbers

2


Course logistics in brief

3

â€¢ Instructor: Christopher Manning

â€¢ Head TA: John Hewitt

â€¢ Course Manager: Amelie Byun. Course Coordinator: John Cho

â€¢ TAs: Many wonderful people! See website

â€¢ Time: Tu/Th 4:30â€“5:50 Pacific time, Nvidia Aud. (â†’ video)

â€¢ Weâ€™ve put a lot of other important information on the class webpage. Please read it!

â€¢ http://cs224n.stanford.edu/

a.k.a., http://www.stanford.edu/class/cs224n/

â€¢ TAs, syllabus, help sessions/office hours, Ed (for all course questions/discussion)

â€¢ Office hours start Wednesday afternoon!

â€¢ Python/numpy and then PyTorch tutorials: First two Fridays. First is 2:30-3:30, Gates B03.

â€¢ Slide PDFs uploaded before each lecture


4




What do we hope to teach? (A.k.a. â€œlearning goalsâ€)

5

1. The foundations of the effective modern methods for deep learning applied to NLP

â€¢ Basics first, then key methods used in NLP in 2023: Word vectors, feed-forward 

networks, recurrent networks, attention, encoder-decoder models, transformers, 

large pre-trained language models, etc.

2. A big picture understanding of human languages and the difficulties in understanding 

and producing them via computers

3. An understanding of and ability to build systems (in PyTorch) for some of the major 

problems in NLP:

â€¢ Word meaning, dependency parsing, machine translation, question answering


Course work and grading policy

â€¢ 5 x 1-week Assignments: 6% + 4 x 12%: 54% 

â€¢ HW1 is released today! Due next Tuesday! At 4:30 p.m.

â€¢ Submitted to Gradescope in Canvas (i.e., using @stanford.edu email for your Gradescope account)

â€¢ Final Default or Custom Course Project (1â€“3 people): 43%

â€¢ Project proposal: 5%, milestone: 5%, poster or web summary: 3%, report: 30%

â€¢ Participation: 3%

â€¢ Guest lecture reactions, Ed, course evals, karma â€“ see website!

â€¢ Late day policy

â€¢ 6 free late days; afterwards, 1% off course grade per day late

â€¢ Assignments not accepted more than 3 days late per assignment unless given permission in advance

â€¢ Collaboration policy: Please read the website and the Honor Code! 

Understand allowed collaboration and how to document it: Donâ€™t take code off the 

web; acknowledge working with other students; write your own assignment solutions

6


High-Level Plan for Assignments (to be completed individually!)

â€¢ Ass1 is hopefully an easy on ramp â€“ a Jupyter/IPython Notebook

â€¢ Ass2 is pure Python (numpy) but expects you to do (multivariate) calculus, so you really 

understand the basics

â€¢ Ass3 introduces PyTorch, building a feed-forward network for dependency parsing

â€¢ Ass4 and Ass5 use PyTorch on a GPU (Microsoft Azure)

â€¢ Libraries like PyTorch, Tensorflow, and Jax are now the standard tools of DL

â€¢ For Final Project, more details presented later, but you either:

â€¢ Do the default project, which is a question answering system

â€¢ Open-ended but an easier start; a good choice for many

â€¢ Propose a custom final project, which we approve

â€¢ You will receive feedback from a mentor (TA/prof/postdoc/PhD)

â€¢ Can work in teams of 1â€“3; can use any language/packages

7


Lecture Plan

1. The course (10 mins)

2. Human language and word meaning (15 mins)

3. Word2vec introduction (15 mins)

4. Word2vec objective function gradients (25 mins)

5. Optimization basics (5 mins)

6. Looking at word vectors (10 mins or less)

8








Trained on text data, neural machine translation is quite good!









https://kiswahili.tuko.co.ke/


The SEC said, â€œMusk, your tweets are a 

blight.

They really could cost you your job,

if you don't stop all this tweeting at night.â€

Then Musk cried, â€œWhy?

The tweets I wrote are not mean,

I don't use all-caps

and I'm sure that my tweets are clean.â€

â€œBut your tweets can move markets

and that's why we're sore.

You may be a genius and a billionaire,

but it doesn't give you the right to

How many users have signed up since the start of 2020?

SELECT count(id) FROM users 

WHERE created_at &gt; â€˜2020-01-01â€™

What is the average number of influencers each user is 

subscribed to?

SELECT avg(count) FROM ( SELECT user_id, count(*) 

FROM subscribers GROUP BY user_id ) 

AS avg_subscriptions_per_user

S: I broke the window.

Q: What did I break?

S: I gracefully saved the day.

Q: What did I gracefully save?

S: I gave John flowers.

Q: Who did I give flowers to?

S: I gave her a rose and a guitar.

Q: Who did I give a rose and a guitar to?

GPT-3: A first step on the path to foundation models



a

be

bore!â€


ChatGPT: A recent, intriguing set of capabilities








ChatGPT: A recent, intriguing set of capabilities












ChatGPT: A recent, intriguing set of capabilities






How do we represent the meaning of a word?

16

Definition: meaning (Webster dictionary)

â€¢

the idea that is represented by a word, phrase, etc.

â€¢

the idea that a person wants to express by using words, signs, etc.

â€¢

the idea that is expressed in a work of writing, art, etc.

Commonest linguistic way of thinking of meaning:

signifier (symbol) âŸº signified (idea or thing)

= denotational semantics

tree âŸº {ğŸŒ³, ğŸŒ², ğŸŒ´, â€¦}


How do we have usable meaning in a computer?

17

Previously commonest NLP solution: Use, e.g., WordNet, a thesaurus containing lists of 

synonym sets and hypernyms (â€œis aâ€ relationships) 



[Synset('procyonid.n.01'), 

Synset('carnivore.n.01'), 

Synset('placental.n.01'), 

Synset('mammal.n.01'), 

Synset('vertebrate.n.01'), 

Synset('chordate.n.01'), 

Synset('animal.n.01'), 

Synset('organism.n.01'), 

Synset('living_thing.n.01'), 

Synset('whole.n.02'), 

Synset('object.n.01'), 

Synset('physical_entity.n.01'), 

Synset('entity.n.01')]



noun: good 

noun: good, goodness 

noun: good, goodness 

noun: commodity, trade_good, good 

adj: good 

adj (sat): full, good 

adj: good 

adj (sat): estimable, good, honorable, respectable 

adj (sat): beneficial, good 

adj (sat): good 

adj (sat): good, just, upright 

â€¦

adverb: well, good 

adverb: thoroughly, soundly, good

e.g., synonym sets containing â€œgoodâ€:

e.g., hypernyms of â€œpandaâ€:

from nltk.corpus import wordnet as wn

poses = { 'n':'noun', 'v':'verb', 's':'adj (s)', 'a':'adj', 'r':'adv'}

for synset in wn.synsets("good"):

print("{}: {}".format(poses[synset.pos()], 

", ".join([l.name() for l in synset.lemmas()])))

from nltk.corpus import wordnet as wn

panda = wn.synset("panda.n.01")

hyper = lambda s: s.hypernyms()

list(panda.closure(hyper))


Problems with resources like WordNet

18

â€¢

A useful resource but missing nuance:

â€¢

e.g., â€œproficientâ€ is listed as a synonym for â€œgoodâ€

This is only correct in some contexts

â€¢

Also, WordNet list offensive synonyms in some synonym sets without any 

coverage of the connotations or appropriateness of words

â€¢

Missing new meanings of words:

â€¢

e.g., wicked, badass, nifty, wizard, genius, ninja, bombest

â€¢

Impossible to keep up-to-date!

â€¢

Subjective

â€¢

Requires human labor to create and adapt

â€¢

Canâ€™t be used to accurately compute word similarity (see following slides)


Representing words as discrete symbols

19

In traditional NLP, we regard words as discrete symbols: 

hotel, conference, motel â€“ a localist representation

Such symbols for words can be represented by one-hot vectors:

motel = [0 0 0 0 0 0 0 0 0 0 1 0 0 0 0]

hotel = [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0]

Vector dimension = number of words in vocabulary (e.g., 500,000+)

Means one 1, the rest 0s


Problem with words as discrete symbols

Example: in web search, if a user searches for â€œSeattle motelâ€, we would like to match 

documents containing â€œSeattle hotelâ€

But:

motel = [0 0 0 0 0 0 0 0 0 0 1 0 0 0 0]

hotel = [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0]

These two vectors are orthogonal

There is no natural notion of similarity for one-hot vectors!

Solution:

â€¢ Could try to rely on WordNetâ€™s list of synonyms to get similarity?

â€¢ But it is well-known to fail badly: incompleteness, etc.

â€¢ Instead: learn to encode similarity in the vectors themselves

Sec. 9.2.2

20


Representing words by their context

21

â€¢ Distributional semantics: A wordâ€™s meaning is given

by the words that frequently appear close-by

â€¢ â€œYou shall know a word by the company it keepsâ€ (J. R. Firth 1957: 11)

â€¢ One of the most successful ideas of modern statistical NLP!

â€¢ When a word w appears in a text, its context is the set of words that appear nearby 

(within a fixed-size window).

â€¢ We use the many contexts of w to build up a representation of w

â€¦government debt problems turning into banking crises as happened in 2009â€¦

â€¦saying that Europe needs unified banking regulation to replace the hodgepodgeâ€¦

â€¦India has just given its banking system a shot in the armâ€¦

These context words will represent banking




Word vectors

22

We will build a dense vector for each word, chosen so that it is similar to vectors of words 

that appear in similar contexts, measuring similarity as the vector dot (scalar) product

Note: word vectors are also called (word) embeddings or (neural) word representations

They are a distributed representation

banking  =

0.286

0.792

âˆ’0.177

âˆ’0.107

0.109

âˆ’0.542

0.349

0.271

monetary  =

0.413

0.582

âˆ’0.007

0.247

0.216

âˆ’0.718

0.147

0.051








Word meaning as a neural word vector â€“ visualization



0.286

0.792

âˆ’0.177

âˆ’0.107

0.109

âˆ’0.542

0.349

0.271

0.487

expect  =

23


3. Word2vec: Overview

Word2vec (Mikolov et al. 2013) is a framework for learning word vectors

Idea:

â€¢ We have a large corpus (â€œbodyâ€) of text: a long list of words

â€¢ Every word in a fixed vocabulary is represented by a vector

â€¢ Go through each position t in the text, which has a center word c and context 

(â€œoutsideâ€) words o

â€¢ Use the similarity of the word vectors for c and o to calculate the probability of o given 

c (or vice versa)

â€¢ Keep adjusting the word vectors to maximize this probability

24


Word2Vec Overview

Example windows and process for computing ğ‘ƒ ğ‘¤ğ‘¡+ğ‘— | ğ‘¤ğ‘¡

â€¦

crises

banking

into

turning

problems

â€¦

as

center word

at position t

outside context words

in window of size 2

outside context words

in window of size 2

ğ‘ƒ ğ‘¤ğ‘¡+1 | ğ‘¤ğ‘¡

ğ‘ƒ ğ‘¤ğ‘¡+2 | ğ‘¤ğ‘¡

ğ‘ƒ ğ‘¤ğ‘¡âˆ’1 | ğ‘¤ğ‘¡

ğ‘ƒ ğ‘¤ğ‘¡âˆ’2 | ğ‘¤ğ‘¡

25


Word2Vec Overview

Example windows and process for computing ğ‘ƒ ğ‘¤ğ‘¡+ğ‘— | ğ‘¤ğ‘¡

â€¦

crises

banking

into

turning

problems

â€¦

as

center word

at position t

outside context words

in window of size 2

outside context words

in window of size 2

ğ‘ƒ ğ‘¤ğ‘¡+1 | ğ‘¤ğ‘¡

ğ‘ƒ ğ‘¤ğ‘¡+2 | ğ‘¤ğ‘¡

ğ‘ƒ ğ‘¤ğ‘¡âˆ’1 | ğ‘¤ğ‘¡

ğ‘ƒ ğ‘¤ğ‘¡âˆ’2 | ğ‘¤ğ‘¡

26


Word2vec: objective function

27

For each position ğ‘¡ = 1, â€¦ , ğ‘‡, predict context words within a window of fixed size m, 

given center word ğ‘¤ğ‘¡. Data likelihood:

ğ¿ ğœƒ = à·‘

ğ‘¡=1

ğ‘‡

à·‘

âˆ’ğ‘šâ‰¤ğ‘—â‰¤ğ‘š

ğ‘—â‰ 0

ğ‘ƒ ğ‘¤ğ‘¡+ğ‘— | ğ‘¤ğ‘¡; ğœƒ

The objective function ğ½ ğœƒ is the (average) negative log likelihood:

ğ½ ğœƒ = âˆ’ 1

ğ‘‡ log ğ¿(ğœƒ) = âˆ’ 1

ğ‘‡ à·

ğ‘¡=1

ğ‘‡

à·

âˆ’ğ‘šâ‰¤ğ‘—â‰¤ğ‘š

ğ‘—â‰ 0

log ğ‘ƒ ğ‘¤ğ‘¡+ğ‘— | ğ‘¤ğ‘¡; ğœƒ

Minimizing objective function âŸº Maximizing predictive accuracy

Likelihood =

ğœƒ is all variables 

to be optimized

sometimes called a cost or loss function


Word2vec: objective function

28

â€¢

We want to minimize the objective function:

ğ½ ğœƒ = âˆ’ 1

ğ‘‡ à·

ğ‘¡=1

ğ‘‡

à·

âˆ’ğ‘šâ‰¤ğ‘—â‰¤ğ‘š

ğ‘—â‰ 0

log ğ‘ƒ ğ‘¤ğ‘¡+ğ‘— | ğ‘¤ğ‘¡; ğœƒ

â€¢

Question: How to calculate ğ‘ƒ ğ‘¤ğ‘¡+ğ‘— | ğ‘¤ğ‘¡; ğœƒ ?

â€¢

Answer: We will use two vectors per word w:

â€¢

ğ‘£ğ‘¤ when w is a center word

â€¢

ğ‘¢ğ‘¤ when w is a context word

â€¢

Then for a center word c and a context word o:

ğ‘ƒ ğ‘œ ğ‘ =

exp(ğ‘¢ğ‘œğ‘‡ğ‘£ğ‘)

Ïƒğ‘¤âˆˆğ‘‰ exp(ğ‘¢ğ‘¤ğ‘‡ ğ‘£ğ‘)


Word2Vec with Vectors

â€¢

Example windows and process for computing ğ‘ƒ ğ‘¤ğ‘¡+ğ‘— | ğ‘¤ğ‘¡

â€¢

ğ‘ƒ ğ‘¢ğ‘ğ‘Ÿğ‘œğ‘ğ‘™ğ‘’ğ‘šğ‘  | ğ‘£ğ‘–ğ‘›ğ‘¡ğ‘œ short for P ğ‘ğ‘Ÿğ‘œğ‘ğ‘™ğ‘’ğ‘šğ‘  | ğ‘–ğ‘›ğ‘¡ğ‘œ ; ğ‘¢ğ‘ğ‘Ÿğ‘œğ‘ğ‘™ğ‘’ğ‘šğ‘ , ğ‘£ğ‘–ğ‘›ğ‘¡ğ‘œ, ğœƒ

â€¦

crises

banking

into

turning

problems

â€¦

as

center word

at position t

outside context words

in window of size 2

outside context words

in window of size 2

ğ‘ƒ ğ‘¢ğ‘ğ‘ğ‘›ğ‘˜ğ‘–ğ‘›ğ‘” |ğ‘£ğ‘–ğ‘›ğ‘¡ğ‘œ

ğ‘ƒ ğ‘¢ğ‘ğ‘Ÿğ‘–ğ‘ ğ‘–ğ‘  |ğ‘£ğ‘–ğ‘›ğ‘¡ğ‘œ

ğ‘ƒ ğ‘¢ğ‘¡ğ‘¢ğ‘›ğ‘–ğ‘›ğ‘” | ğ‘£ğ‘–ğ‘›ğ‘¡ğ‘œ

ğ‘ƒ ğ‘¢ğ‘ğ‘Ÿğ‘œğ‘ğ‘™ğ‘’ğ‘šğ‘  | ğ‘£ğ‘–ğ‘›ğ‘¡ğ‘œ

29

All words vectors ğœƒ

appear in denominator


Word2vec: prediction function

ğ‘ƒ ğ‘œ ğ‘ =

exp(ğ‘¢ğ‘œğ‘‡ğ‘£ğ‘)

Ïƒğ‘¤âˆˆğ‘‰ exp(ğ‘¢ğ‘¤ğ‘‡ ğ‘£ğ‘)

â€¢ This is an example of the softmax function â„ğ‘› â†’ (0,1)ğ‘›

softmax ğ‘¥ğ‘– =

exp(ğ‘¥ğ‘–)

Ïƒğ‘—=1

ğ‘›

exp(ğ‘¥ğ‘—) = ğ‘ğ‘–

â€¢ The softmax function maps arbitrary values ğ‘¥ğ‘– to a probability distribution ğ‘ğ‘–

â€¢ â€œmaxâ€ because amplifies probability of largest ğ‘¥ğ‘–

â€¢ â€œsoftâ€ because still assigns some probability to smaller ğ‘¥ğ‘–

â€¢ Frequently used in Deep Learning

â‘  Dot product compares similarity of o and c.

ğ‘¢ğ‘‡ğ‘£ = ğ‘¢. ğ‘£ = Ïƒğ‘–=1

ğ‘›

ğ‘¢ğ‘–ğ‘£ğ‘–

Larger dot product = larger probability

â‘¢ Normalize over entire vocabulary 

to give probability distribution

30

â‘¡ Exponentiation makes anything positive

Open 

region

But sort of a weird name 

because it returns a distribution!


To train the model: Optimize value of parameters to minimize loss

31

To train a model, we gradually adjust parameters to minimize a loss

â€¢ Recall: ğœƒ represents all the 

model parameters, in one

long vector

â€¢ In our case, with 

d-dimensional vectors and 

V-many words, we have â†’

â€¢ Remember: every word has 

two vectors

â€¢ We optimize these parameters by walking down the gradient (see right figure)

â€¢ We compute all vector gradients!








32

4.




33




34




35


5. Optimization: Gradient Descent

â€¢ We have a cost function ğ½ ğœƒ we want to minimize

â€¢ Gradient Descent is an algorithm to minimize ğ½ ğœƒ

â€¢ Idea: for current value of ğœƒ, calculate gradient of ğ½ ğœƒ , then take small step in direction 

of negative gradient. Repeat.



Note: Our 

objectives

may not 

be convex

like this ïŒ

But life turns 

out to be 

okay â˜º

36


â€¢ Update equation (in matrix notation):

â€¢ Update equation (for single parameter):

â€¢ Algorithm:

Gradient Descent





ğ›¼ = step size or learning rate



37


Stochastic Gradient Descent

â€¢ Problem: ğ½ ğœƒ is a function of all windows in the corpus (potentially billions!)

â€¢ So                 is very expensive to compute

â€¢ You would wait a very long time before making a single update!

â€¢ Very bad idea for pretty much all neural nets!

â€¢ Solution: Stochastic gradient descent (SGD)

â€¢

Repeatedly sample windows, and update after each one

â€¢ Algorithm:





38


Lecture Plan

1. The course (10 mins)

2. Human language and word meaning (15 mins)

3. Word2vec introduction (15 mins)

4. Word2vec objective function gradients (25 mins)

5. Optimization basics (5 mins)

6. Looking at word vectors (10 mins or less)

â€¢

See Jupyter Notebook

39


40

